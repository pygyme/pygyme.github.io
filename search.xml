<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Windows开发环境解决方案</title>
    <url>/posts/d7d999a2.html</url>
    <content><![CDATA[<h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h2><h3 id="DIY台式电脑"><a href="#DIY台式电脑" class="headerlink" title="DIY台式电脑"></a>DIY台式电脑</h3><ul>
<li>CPU： 5950X</li>
<li>GPU： 4070Ti</li>
<li>内存: 128GB DDR4</li>
<li>硬盘：4T PCIE4.0 SSD</li>
<li>系统：Windows 11 24H2 专业工作站版</li>
</ul>
<p>现在192GB内存已经很稳，消费级主板已经支持 256GB DDR5了，但是目前还没有单条64GB的DDR5内存上市，感觉消费级主板完全满足需求了。</p>
<span id="more"></span>

<h2 id="开发环境需求"><a href="#开发环境需求" class="headerlink" title="开发环境需求"></a>开发环境需求</h2><p>1.跑多个Linux虚拟机，（多节点应用集群、数据库集群、后端程序编译），需要 多核CPU、大容量内存、高性能M2硬盘(IOPS)</p>
<p>2.数据备份存储<br>    方案1： 8块8T硬盘，   ZFS Raidz2， 6&#x2F;(6+2)   48TB容量<br>    方案2： 8块10TB硬盘， ZFS Raidz2， 6&#x2F;(6+2)   60TB容量<br>    方案3： 4块8TB硬盘，  ZFS Raidz1， 3&#x2F;(3+1)   24TB容量， 后期再加4块 8TB硬盘<br>    方案4： 4块10TB硬盘， ZFS Raidz1， 3&#x2F;(3+1)   30TB容量， 后期再加4块10TB硬盘</p>
<p>3.万兆网络（光纤 or 6类线 ？？？）<br>    方案1： 万兆交换机+网线+电脑<br>    方案2： 虚拟化网络(10Gb,25Gb,40Gb)， 依赖CPU性能</p>
<p>4.显卡直通<br>    真的需要直通显卡吗？ 除了游戏<br>    需求方案1： Intel DG1， vGPU支持桌面系统(win10、win11、Linux Desktop)，只是亮机，能流畅运行图形界面，没有专业应用和游戏<br>    需求方案2： RTX 4070TI， 直通独占显卡，用来打游戏， 但是好像也能用于专业应用</p>
<p>想来想去，其实就是需要一台服务器 + 一台台式电脑， 上面提到的都是服务器需求。</p>
<p>服务器和台式电脑之间通过交换机+网线连接， 网线可以是光纤or6类线，主要取决于交换机+线缆+万兆网卡的价格。</p>
<h2 id="我的解决方案"><a href="#我的解决方案" class="headerlink" title="我的解决方案"></a>我的解决方案</h2><p>只有一台台式电脑，Windows下Hyper-V用起来不如VMware方便，因此使用VMware Workstation Pro进行虚拟化。</p>
<p>方案说明：</p>
<ul>
<li>物理机安装Windows，所有软件安装在C盘。在PE环境下，使用 DiskGenius 对C盘做磁盘镜像，实现Windows系统备份。</li>
<li>Windows下完全关闭Hyper-V，因为安装PVE时，Hyper-V会跟 VMware 有冲突。</li>
<li>使用 VMware Workstation Pro 安装PVE8虚拟机， 开机自启动运行，充当服务器的角色。</li>
<li>使用 VMware Workstation Pro 安装Ubuntu虚拟机，有了Linux开发环境。</li>
</ul>
<h2 id="关闭Hyper-V虚拟化，这意味着："><a href="#关闭Hyper-V虚拟化，这意味着：" class="headerlink" title="关闭Hyper-V虚拟化，这意味着："></a>关闭Hyper-V虚拟化，这意味着：</h2><ul>
<li>不能使用 WSL2， </li>
<li>不能使用 Docker Desktop</li>
<li>放心使用 安卓模拟器， 不必担心 Hyper-V 冲突。</li>
</ul>
<h3 id="WSL2替代方案"><a href="#WSL2替代方案" class="headerlink" title="WSL2替代方案"></a>WSL2替代方案</h3><p>WSL2说到底就是一个Linux虚拟机， 那我通过直接使用 VMware Workstation Pro 创建的Ubuntu虚拟机就好了。</p>
<p>因为我不需要用到很强的图形性能，所以直接使用Linux虚拟机对我来说没什么影响。</p>
<p>如果对图形性能有很强的需求，还需要在Linux环境下使用，推荐直接使用Linux物理机或者GPU直通。</p>
<h3 id="Docker-Desktop-替代方案"><a href="#Docker-Desktop-替代方案" class="headerlink" title="Docker Desktop 替代方案"></a>Docker Desktop 替代方案</h3><p>Docker本就起源于Linux， 直接在Ubuntu虚拟机安装使用Docker就好了。</p>
<ol>
<li><p>如何在物理机Windows上使用docker打镜像？</p>
<p> 第一步：把Windows的D盘、E盘设置为共享， 在Ubuntu虚拟机里面，使用CIFS挂载共享文件夹到 <code>/mnt/d</code> , <code>/mnt/e</code> ，解决虚拟机访问Windows文件的问题。</p>
<p> 第二步：使用 Xshell SSH 登录到Ubuntu虚拟机， 切换到对应位置， 执行打镜像的命令。</p>
<p> 第三步：在Ubuntu虚拟机里面安装 portainer ，用来管理docker。 信我，这玩意比 Docker Desktop 好用多了。</p>
</li>
</ol>
<h2 id="VMware网络规划"><a href="#VMware网络规划" class="headerlink" title="VMware网络规划"></a>VMware网络规划</h2><p>VMware网络设置：</p>
<ul>
<li>VMware Workstation Pro NAT网络VMnet8，网段为 172.17.0.0&#x2F;16，网关是 172.17.0.2</li>
<li>VMware Workstation Pro 仅主机网络VMnet1，网段为 192.168.17.0&#x2F;24</li>
<li>VMware Workstation Pro 桥接网络</li>
</ul>
<p>对于局域网其他设备要访问PVE虚拟机的这个问题，最好的解决办法是再添加一块网卡，连接方式设置为桥接，直接连到局域网内；别想着用Linux&#x2F;Windows路由转发，那玩意过于麻烦，根本不适合这个使用场景。</p>
<h3 id="PVE虚拟机配置"><a href="#PVE虚拟机配置" class="headerlink" title="PVE虚拟机配置"></a>PVE虚拟机配置</h3><p>PVE虚拟机有两块网卡。</p>
<ul>
<li>第一块网卡叫ens33，连接到NAT网络VMnet8上面。</li>
<li>第二块网卡叫ens32，连接到桥接网络。</li>
</ul>
<p>在PVE管理界面，基于 ens33 创建网桥（Linux Bridge），名字叫<code>vmbr0</code>，用于虚拟机上网。 PVE创建的虚拟机，默认都连接到vmbr0网桥，并且配置了静态IP地址。</p>
<p>在PVE管理界面，基于 ens33 创建网桥（Linux Bridge），名字叫<code>vmbr1</code>，让家庭局域网的其他设备可以访问PVE创建的虚拟机，比如：访问群晖NAS。</p>
<p>如果后续有机会迁移升级，要把PVE虚拟机换成PVE物理机，只要把局域网网段改成 172.17.0.0&#x2F;16 网段就可以，再修改一下VMware网络设置即可。</p>
<h3 id="Ubuntu虚拟机配置"><a href="#Ubuntu虚拟机配置" class="headerlink" title="Ubuntu虚拟机配置"></a>Ubuntu虚拟机配置</h3><p>Ubuntu虚拟机使用NAT网络VMnet8， 就可以访问PVE创建的虚拟机了，很方便！</p>
]]></content>
      <categories>
        <category>虚拟化技术</category>
      </categories>
  </entry>
  <entry>
    <title>Kubeadm高可用Kubernetes集群</title>
    <url>/posts/6f07dab1.html</url>
    <content><![CDATA[<h1 id="Kubeadm高可用Kubernetes集群"><a href="#Kubeadm高可用Kubernetes集群" class="headerlink" title="Kubeadm高可用Kubernetes集群"></a>Kubeadm高可用Kubernetes集群</h1><h2 id="Kubernetes集群信息概览"><a href="#Kubernetes集群信息概览" class="headerlink" title="Kubernetes集群信息概览"></a>Kubernetes集群信息概览</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\lukas&gt; kubectl get nodes <span class="literal">-o</span> wide</span><br><span class="line">NAME                   STATUS   ROLES                  AGE   VERSION   INTERNAL<span class="literal">-IP</span>   EXTERNAL<span class="literal">-IP</span>   OS<span class="literal">-IMAGE</span>                                   KERNEL<span class="literal">-VERSION</span>                 CONTAINER<span class="literal">-RUNTIME</span></span><br><span class="line">k8s<span class="literal">-control-plane-01</span>   Ready    control<span class="literal">-plane</span>,master   <span class="number">22</span><span class="built_in">h</span>   v1.<span class="number">34.1</span>   <span class="number">172.17</span>.<span class="number">2.11</span>   &lt;none&gt;        Red Hat Enterprise Linux <span class="number">10.0</span> (Coughlan)   <span class="number">6.12</span>.<span class="number">0</span><span class="literal">-55</span>.<span class="number">41.1</span>.el10_0.x86_64   docker://<span class="number">28.5</span>.<span class="number">1</span></span><br><span class="line">k8s<span class="literal">-control-plane-02</span>   Ready    control<span class="literal">-plane</span>,master   <span class="number">22</span><span class="built_in">h</span>   v1.<span class="number">34.1</span>   <span class="number">172.17</span>.<span class="number">2.12</span>   &lt;none&gt;        Red Hat Enterprise Linux <span class="number">10.0</span> (Coughlan)   <span class="number">6.12</span>.<span class="number">0</span><span class="literal">-55</span>.<span class="number">41.1</span>.el10_0.x86_64   docker://<span class="number">28.5</span>.<span class="number">1</span></span><br><span class="line">k8s<span class="literal">-control-plane-03</span>   Ready    control<span class="literal">-plane</span>,master   <span class="number">22</span><span class="built_in">h</span>   v1.<span class="number">34.1</span>   <span class="number">172.17</span>.<span class="number">2.13</span>   &lt;none&gt;        Red Hat Enterprise Linux <span class="number">10.0</span> (Coughlan)   <span class="number">6.12</span>.<span class="number">0</span><span class="literal">-55</span>.<span class="number">41.1</span>.el10_0.x86_64   docker://<span class="number">28.5</span>.<span class="number">1</span></span><br><span class="line">k8s<span class="literal">-worker-01</span>          Ready    worker                 <span class="number">22</span><span class="built_in">h</span>   v1.<span class="number">34.1</span>   <span class="number">172.17</span>.<span class="number">2.21</span>   &lt;none&gt;        Red Hat Enterprise Linux <span class="number">10.0</span> (Coughlan)   <span class="number">6.12</span>.<span class="number">0</span><span class="literal">-55</span>.<span class="number">41.1</span>.el10_0.x86_64   docker://<span class="number">28.5</span>.<span class="number">1</span></span><br><span class="line">k8s<span class="literal">-worker-02</span>          Ready    worker                 <span class="number">22</span><span class="built_in">h</span>   v1.<span class="number">34.1</span>   <span class="number">172.17</span>.<span class="number">2.22</span>   &lt;none&gt;        Red Hat Enterprise Linux <span class="number">10.0</span> (Coughlan)   <span class="number">6.12</span>.<span class="number">0</span><span class="literal">-55</span>.<span class="number">41.1</span>.el10_0.x86_64   docker://<span class="number">28.5</span>.<span class="number">1</span></span><br><span class="line">k8s<span class="literal">-worker-03</span>          Ready    worker                 <span class="number">22</span><span class="built_in">h</span>   v1.<span class="number">34.1</span>   <span class="number">172.17</span>.<span class="number">2.23</span>   &lt;none&gt;        Red Hat Enterprise Linux <span class="number">10.0</span> (Coughlan)   <span class="number">6.12</span>.<span class="number">0</span><span class="literal">-55</span>.<span class="number">41.1</span>.el10_0.x86_64   docker://<span class="number">28.5</span>.<span class="number">1</span></span><br><span class="line">k8s<span class="literal">-worker-04</span>          Ready    worker                 <span class="number">22</span><span class="built_in">h</span>   v1.<span class="number">34.1</span>   <span class="number">172.17</span>.<span class="number">2.24</span>   &lt;none&gt;        Red Hat Enterprise Linux <span class="number">10.0</span> (Coughlan)   <span class="number">6.12</span>.<span class="number">0</span><span class="literal">-55</span>.<span class="number">41.1</span>.el10_0.x86_64   docker://<span class="number">28.5</span>.<span class="number">1</span></span><br><span class="line">k8s<span class="literal">-worker-05</span>          Ready    worker                 <span class="number">22</span><span class="built_in">h</span>   v1.<span class="number">34.1</span>   <span class="number">172.17</span>.<span class="number">2.25</span>   &lt;none&gt;        Red Hat Enterprise Linux <span class="number">10.0</span> (Coughlan)   <span class="number">6.12</span>.<span class="number">0</span><span class="literal">-55</span>.<span class="number">41.1</span>.el10_0.x86_64   docker://<span class="number">28.5</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:\Users\lukas&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个高可用Kubernetes集群，由3个控制面节点，5个数据面节点构成，使用Kubeadm进行部署。</li>
<li>每个节点部署在 Red Hat Enterprise Linux 10.0 上面。</li>
<li>使用 Docker 作为容器运行时，并使用 Portainer 作为Docker管理面板，方便管理Docker容器。</li>
<li>使用 HAProxy四层反向代理 + Keepalived虚拟VIP 来实现 Kubernetes API Server的高可用。</li>
<li>使用 Flannel 作为网络插件，打通Kubernetes集群的所有节点，使节点上的Pod可以相互通信。</li>
<li>使用 MetalLB 作为负载均衡器，让Kubernetes服务可以分配集群外部私有IP地址。</li>
<li>使用 kuboard 作为Kubernetes集群管理面板，全中文、Kubernetes集群外部署、易安装卸载。</li>
<li>使用 ingress-nginx 作为Kubernetes集群的Ingress控制器，统一服务访问入口。</li>
<li>使用 NFS 作为Kubernetes集群的存储卷，方便存储卷分配。</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>（一）Linux系统优化</title>
    <url>/posts/b21d2575.html</url>
    <content><![CDATA[<h1 id="（一）Linux系统优化"><a href="#（一）Linux系统优化" class="headerlink" title="（一）Linux系统优化"></a>（一）Linux系统优化</h1><h2 id="节点配置Hosts"><a href="#节点配置Hosts" class="headerlink" title="节点配置Hosts"></a>节点配置Hosts</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># /etc/hosts</span><br><span class="line"># Kubernetes Hosts</span><br><span class="line">172.17.2.11  k8s-control-plane-01</span><br><span class="line">172.17.2.12  k8s-control-plane-02</span><br><span class="line">172.17.2.13  k8s-control-plane-03</span><br><span class="line">172.17.2.21  k8s-worker-01</span><br><span class="line">172.17.2.22  k8s-worker-02</span><br><span class="line">172.17.2.23  k8s-worker-03</span><br><span class="line">172.17.2.24  k8s-worker-04</span><br><span class="line">172.17.2.25  k8s-worker-05</span><br></pre></td></tr></table></figure>

<ul>
<li>每个节点上面改成对应的hostname</li>
</ul>
<h2 id="优化系统服务"><a href="#优化系统服务" class="headerlink" title="优化系统服务"></a>优化系统服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 安装需要的软件包</span></span><br><span class="line">yum install -y iproute-tc ipvsadm ipset expect sshpass</span><br><span class="line"></span><br><span class="line"><span class="comment">## 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld &amp;&amp; systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 iptables</span></span><br><span class="line"><span class="comment">#iptables -F &amp;&amp; iptables -X &amp;&amp; iptables -F -t nat &amp;&amp; iptables -X -t nat</span></span><br><span class="line"><span class="comment">#iptables -P FORWARD ACCEPT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 关闭交换空间</span></span><br><span class="line">swapoff -a</span><br><span class="line">sed -i <span class="string">&#x27;/ swap / s/^\(.*\)$/#\1/g&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 关闭SELinux安全机制</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i <span class="string">&#x27;s/^SELINUX=.*/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 所有节点设置系统时区</span></span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment">#将当前的 UTC 时间写入硬件时钟</span></span><br><span class="line">timedatectl set-local-rtc 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启依赖于系统时间的服务</span></span><br><span class="line">systemctl restart rsyslog </span><br><span class="line">systemctl restart crond</span><br></pre></td></tr></table></figure>

<h2 id="优化内核参数"><a href="#优化内核参数" class="headerlink" title="优化内核参数"></a>优化内核参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | tee /etc/sysctl.d/kubernetes.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables=1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables=1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward=1</span></span><br><span class="line"><span class="string">vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它</span></span><br><span class="line"><span class="string">vm.overcommit_memory=1 # 不检查物理内存是否够用</span></span><br><span class="line"><span class="string">vm.panic_on_oom=0 # 开启 OOM</span></span><br><span class="line"><span class="string">fs.inotify.max_user_instances=8192</span></span><br><span class="line"><span class="string">fs.inotify.max_user_watches=1048576</span></span><br><span class="line"><span class="string">fs.file-max=52706963</span></span><br><span class="line"><span class="string">fs.nr_open=52706963</span></span><br><span class="line"><span class="string">net.ipv6.conf.all.disable_ipv6=1</span></span><br><span class="line"><span class="string">net.netfilter.nf_conntrack_max=2310720</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sysctl -p /etc/sysctl.d/kubernetes.conf</span><br></pre></td></tr></table></figure>

<h2 id="开机加载内核模块"><a href="#开机加载内核模块" class="headerlink" title="开机加载内核模块"></a>开机加载内核模块</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> br_netfilter &gt; /etc/modules-load.d/br_netfilter.conf</span><br><span class="line"><span class="built_in">echo</span> nf_conntrack &gt; /etc/modules-load.d/nf_conntrack.conf</span><br><span class="line"><span class="built_in">echo</span> ip_vs &gt; /etc/modules-load.d/ip_vs.conf</span><br><span class="line"><span class="built_in">echo</span> ip_vs_rr &gt; /etc/modules-load.d/ip_vs_rr.conf</span><br><span class="line"><span class="built_in">echo</span> ip_vs_wrr &gt; /etc/modules-load.d/ip_vs_wrr.conf</span><br><span class="line"><span class="built_in">echo</span> ip_vs_sh &gt; /etc/modules-load.d/ip_vs_sh.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>上面写的是 RHEL10 开机自动加载内核模块的方法，其他Linux系统自己找一下对应的方法，总之就是要开机自动加载这些内核模块。</li>
<li>如果这些内核模块没有加载，会导致kube-flannel无法正常运行，进一步导致MetalLB无法正常运行，最终结果就是，虽然集群节点已经Ready，但是集群上面部署的服务无法正常启动，一直报错。</li>
<li>Kubernetes集群的每一个节点都要配置开机自动加载这些内核模块，因为每个节点都需要运行 kube-flannel，否则节点之间无法相互通信。</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>（二）安装Docker容器运行时</title>
    <url>/posts/11da3e0.html</url>
    <content><![CDATA[<h1 id="（二）安装Docker容器运行时"><a href="#（二）安装Docker容器运行时" class="headerlink" title="（二）安装Docker容器运行时"></a>（二）安装Docker容器运行时</h1><ul>
<li>需要特别注意的是： Kubernetes集群部署过程中，Docker拉取镜像，由于存在网络问题，因此Docker必须代理，才能正常拉取镜像。</li>
<li>如果你没有一个速度快的网络代理，那还是别往下看了，网络问题会导致后面的部署各种不顺畅，不建议进行后续部署。</li>
</ul>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rhel</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一台机器上快速部署 docker-ce</span></span><br><span class="line">set -euo pipefail</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置应用变量</span></span></span><br><span class="line">proxy_addr=&quot;http://172.17.0.1:5071&quot;</span><br><span class="line">pod_cidr=&quot;10.80.0.0/12&quot;</span><br><span class="line">service_cidr=&quot;10.96.0.0/12&quot;</span><br><span class="line">lan_cidr=&quot;172.17.0.0/16&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dnf config-manager --setopt proxy=$proxy_addr --save</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">podman 和 docker-ce 的包存在冲突, 要先卸载 podman</span></span><br><span class="line">dnf remove -y podman</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 安装 docker-ce</span></span></span><br><span class="line">dnf config-manager --add-repo=https://download.docker.com/linux/rhel/docker-ce.repo</span><br><span class="line">dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 安装 dodocker-compose</span></span></span><br><span class="line">install -o root -g root -m 0755 soft/docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置 docker http代理</span></span></span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">cat &lt;&lt;EOF | tee /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=$proxy_addr&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=$proxy_addr&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=harbor.local,harbor.k8s.local,.local,.k8s.local,$service_cidr,$pod_cidr,$lan_cidr&quot;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 重启 docker 服务</span></span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable --now docker.service</span><br><span class="line">systemctl restart docker.service</span><br><span class="line"></span><br><span class="line">systemctl status --no-pager docker.service</span><br></pre></td></tr></table></figure>

<ul>
<li>使用上面的脚本在RHEL10上面快速部署Docker，并配置代理，从而确保镜像拉取无网络问题。</li>
<li><code>10.80.0.0/12</code> 是Kubernetes集群的Pod网段。</li>
<li><code>10.96.0.0/12</code> 是Kubernetes集群的服务网段。</li>
<li><code>172.17.0.0/16</code> 是本地局域网网段。</li>
<li><code>http://172.17.0.1:5071</code> 是HTTP代理地址。</li>
</ul>
<h2 id="安装-cri-dockerd"><a href="#安装-cri-dockerd" class="headerlink" title="安装 cri-dockerd"></a>安装 cri-dockerd</h2><p>由于Kubernetes统一了容器运行时接口，不再仅仅依赖Docker，因此在安装完Docker，还需要安装 cri-dockerd，才能将 Docker 作为Kubernetes集群的容器运行时。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">https://github.com/Mirantis/cri-dockerd</span><br><span class="line"></span><br><span class="line">https://github.com/Mirantis/cri-dockerd/releases/tag/v0.3.21</span><br></pre></td></tr></table></figure>

<p>下载 <code>cri-dockerd-0.3.21.amd64.tgz</code> 进行安装， 确保 <code>docker.service</code>、<code>cri-docker.service</code>、<code>cri-docker.socket</code> 这几个服务都能正常运行，并设置开机自动启动。</p>
<h2 id="要注意的点"><a href="#要注意的点" class="headerlink" title="要注意的点"></a>要注意的点</h2><ul>
<li>Kubernetes集群的每一个节点都需要安装 Docker 和 cri-dockerd 。</li>
</ul>
<h2 id="安装-portainer"><a href="#安装-portainer" class="headerlink" title="安装 portainer"></a>安装 portainer</h2><ul>
<li>portainer 是一个Web管理面板，用于管理Docker，可以让我们避免重复敲Docker命令。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># shellcheck disable=SC1000-SC9999</span><br><span class="line">set -euo pipefail</span><br><span class="line"></span><br><span class="line">#------------------------------------------------------------------------------#----------------------------------------</span><br><span class="line"># 部署 portainer 服务</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart docker.service</span><br><span class="line"></span><br><span class="line">docker volume create portainer_data</span><br><span class="line"></span><br><span class="line"># -p 本地端口：容器端口</span><br><span class="line">docker run -d -p 8000:8000 -p 9443:9443 --name portainer \</span><br><span class="line">    --restart=always \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    -v portainer_data:/data \</span><br><span class="line">    portainer/portainer-ce:2.33.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 初始化访问地址：https://localhost:9443</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>（三）HAProxy与Keepalived实现APIServer高可用</title>
    <url>/posts/c12237c1.html</url>
    <content><![CDATA[<h1 id="（三）HAProxy与Keepalived实现APIServer高可用"><a href="#（三）HAProxy与Keepalived实现APIServer高可用" class="headerlink" title="（三）HAProxy与Keepalived实现APIServer高可用"></a>（三）HAProxy与Keepalived实现APIServer高可用</h1><h2 id="Kubernetes-API-Server-节点信息说明与解决方案"><a href="#Kubernetes-API-Server-节点信息说明与解决方案" class="headerlink" title="Kubernetes API Server 节点信息说明与解决方案"></a>Kubernetes API Server 节点信息说明与解决方案</h2><p>集群有三个控制面节点，6443为 API Server默认端口，三个控制面节点对应的 API Server 地址如下：</p>
<ul>
<li>172.17.2.11:6443</li>
<li>172.17.2.12:6443</li>
<li>172.17.2.13:6443</li>
</ul>
<p>那么如何实现集群控制面节点 API Server 的高可用呢？</p>
<p>解决方案是：</p>
<ul>
<li>每个控制面节点上安装HAProxy，使用8443端口来实现四层反向代理6443端口。</li>
<li>每个控制面节点上安装Keepalived，配置一个浮动的虚拟IP地址<code>172.17.2.10</code>，在三个节点之间浮动。</li>
<li>结合起来就是： 使用 172.17.2.10:8443 作为集群 API Server 的访问地址。</li>
<li>每个数据面节点都使用 <code>172.17.2.10:8443</code> 进行访问。</li>
<li>这样只要控制面三个节点没有全都挂掉，集群就可以正常进行工作，也就实现了我们想要的集群高可用。</li>
</ul>
<h2 id="安装HAProxy与Keepalived"><a href="#安装HAProxy与Keepalived" class="headerlink" title="安装HAProxy与Keepalived"></a>安装HAProxy与Keepalived</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf install -y keepalived haproxy psmisc</span><br><span class="line"></span><br><span class="line">apt-get install -y keepalived haproxy</span><br></pre></td></tr></table></figure>

<h2 id="HAProxy配置文件示例"><a href="#HAProxy配置文件示例" class="headerlink" title="HAProxy配置文件示例"></a>HAProxy配置文件示例</h2><ul>
<li>控制面三个节点都要安装并配置HAProxy。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/haproxy/haproxy.cfg</span><br><span class="line"></span><br><span class="line">global</span><br><span class="line">    log /dev/log  local0 warning</span><br><span class="line">    chroot      /var/lib/haproxy</span><br><span class="line">    pidfile     /var/run/haproxy.pid</span><br><span class="line">    maxconn     4000</span><br><span class="line">    user        haproxy</span><br><span class="line">    group       haproxy</span><br><span class="line">    daemon</span><br><span class="line">   stats socket /var/lib/haproxy/stats</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    mode                    http</span><br><span class="line">    log                     global</span><br><span class="line">    option                  httplog</span><br><span class="line">    option                  dontlognull</span><br><span class="line">    option http-server-close</span><br><span class="line">    option forwardfor       except 127.0.0.0/8</span><br><span class="line">    option                  redispatch</span><br><span class="line">    retries                 1</span><br><span class="line">    timeout http-request    10s</span><br><span class="line">    timeout queue           20s</span><br><span class="line">    timeout connect         5s</span><br><span class="line">    timeout client          20s</span><br><span class="line">    timeout server          20s</span><br><span class="line">    timeout http-keep-alive 10s</span><br><span class="line">    timeout check           10s</span><br><span class="line"></span><br><span class="line">frontend apiserver-frontend</span><br><span class="line">  bind *:8443</span><br><span class="line">  mode tcp</span><br><span class="line">  option tcplog</span><br><span class="line">  default_backend apiserver-backend</span><br><span class="line"></span><br><span class="line">backend apiserver-backend</span><br><span class="line">    option httpchk GET /healthz</span><br><span class="line">    http-check expect status 200</span><br><span class="line">    mode tcp</span><br><span class="line">    option ssl-hello-chk</span><br><span class="line">    balance     roundrobin</span><br><span class="line">    server server01 172.17.2.11:6443 check</span><br><span class="line">    server server02 172.17.2.12:6443 check</span><br><span class="line">    server server03 172.17.2.13:6443 check</span><br></pre></td></tr></table></figure>

<h2 id="Keepalived配置文件示例"><a href="#Keepalived配置文件示例" class="headerlink" title="Keepalived配置文件示例"></a>Keepalived配置文件示例</h2><ul>
<li>控制面三个节点都要安装并配置Keepalived。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/keepalived/keepalived.conf</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id 172.17.2.11       # 节点ip地址，每个节点配置自己的IP地址</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_api_server &#123;</span><br><span class="line">  script &quot;/etc/keepalived/check_apiserver.sh&quot;</span><br><span class="line">  interval 3</span><br><span class="line">  weight -2</span><br><span class="line">  fall 10</span><br><span class="line">  rise 2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens18            # 网络接口名，每个节点配置自己的网络接口名</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass Admin!@#123</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">         chk_api_server</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        172.17.2.10/16         # 虚拟VIP地址，每个节点统一一致</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>（五）部署负载均衡器MetalLB</title>
    <url>/posts/3e760edd.html</url>
    <content><![CDATA[<h1 id="（五）部署负载均衡器MetalLB"><a href="#（五）部署负载均衡器MetalLB" class="headerlink" title="（五）部署负载均衡器MetalLB"></a>（五）部署负载均衡器MetalLB</h1><h2 id="metallb-Github仓库"><a href="#metallb-Github仓库" class="headerlink" title="metallb Github仓库"></a>metallb Github仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/metallb/metallb</span><br><span class="line"></span><br><span class="line">https://github.com/metallb/metallb/releases/tag/v0.15.2</span><br></pre></td></tr></table></figure>

<ul>
<li>从Release里面下载源码包 <code>metallb-0.15.2.zip</code>，</li>
<li>解压得到 <code>metallb-0.15.2\config\manifests\metallb-native.yaml</code> 就是我们需要的文件</li>
</ul>
<h2 id="部署负载均衡器MetalLB"><a href="#部署负载均衡器MetalLB" class="headerlink" title="部署负载均衡器MetalLB"></a>部署负载均衡器MetalLB</h2><ul>
<li>不需要对 <code>metallb-native.yaml</code> 做任何修改，直接<code>kubectl apply</code>就可以了。</li>
<li>只要你的 kube-flannel 网络是正常运行的，那么 MetalLB 通常也会跟着正常运行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f conf/metallb-native-v0.15.2.yaml</span><br></pre></td></tr></table></figure>

<h2 id="配置负载均衡地址池"><a href="#配置负载均衡地址池" class="headerlink" title="配置负载均衡地址池"></a>配置负载均衡地址池</h2><ul>
<li>MetalLB 可以给集群部署的服务分配IP地址，因此需要配置好可供分配的地址池。</li>
</ul>
<p><code>metallb-layer2.yaml</code> 文件内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">metallb.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IPAddressPool</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pool01</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metallb-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.100</span><span class="number">.2</span><span class="number">-172.17</span><span class="number">.120</span><span class="number">.255</span></span><br><span class="line"><span class="comment"># 172.17.100.1 用作 ingress 入口地址</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">metallb.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">L2Advertisement</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pool01-advertisement</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metallb-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ipAddressPools:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pool01</span></span><br></pre></td></tr></table></figure>

<p>直接 <code>kubectl apply -f conf/metallb-layer2.yaml</code> 创建地址池并绑定即可。，</p>
<h2 id="如何检测MetalLB是否正常分配IP地址？"><a href="#如何检测MetalLB是否正常分配IP地址？" class="headerlink" title="如何检测MetalLB是否正常分配IP地址？"></a>如何检测MetalLB是否正常分配IP地址？</h2><p>检测方法是：</p>
<ul>
<li>部署一个nginx服务到集群上，手动指定负载均衡IP地址，观察nginx服务是否可以通过负载均衡IP地址进行访问。</li>
</ul>
<p><code>metallb-layer2-nginx.yaml</code> 文件内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metallb-testing-nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metallb-testing-nginx-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">loadBalancerIP:</span> <span class="string">http://172.17.100.2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <code>curl -vvvvv http://172.17.100.2:80</code>  或者浏览器直接访问该地址进行观察。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>（四）安装Kubeadm组件并创建集群</title>
    <url>/posts/51844224.html</url>
    <content><![CDATA[<h1 id="（四）安装Kubeadm组件并创建集群"><a href="#（四）安装Kubeadm组件并创建集群" class="headerlink" title="（四）安装Kubeadm组件并创建集群"></a>（四）安装Kubeadm组件并创建集群</h1><h2 id="第一步：-各节点安装kubeadm组件"><a href="#第一步：-各节点安装kubeadm组件" class="headerlink" title="第一步： 各节点安装kubeadm组件"></a>第一步： 各节点安装kubeadm组件</h2><ol>
<li>添加仓库repo</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | tee /etc/yum.repos.d/kubernetes.repo </span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://pkgs.k8s.io/core:/stable:/v1.34/rpm/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.34/rpm/repodata/repomd.xml.key</span></span><br><span class="line"><span class="string">exclude=kubelet kubeadm kubectl cri-tools kubernetes-cni</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检查kubeadm版本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-control-plane-01 ~]# yum list --showduplicates kubeadm --disableexcludes=kubernetes</span><br><span class="line">正在更新 Subscription Management 软件仓库。</span><br><span class="line">上次元数据过期检查：2:18:23 前，执行于 2024年12月20日 星期五 20时09分59秒。</span><br><span class="line">已安装的软件包</span><br><span class="line">kubeadm.x86_64                                              1.31.4-150500.1.1                                         @kubernetes</span><br><span class="line">可安装的软件包</span><br><span class="line">kubeadm.aarch64                                             1.31.0-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.ppc64le                                             1.31.0-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.s390x                                               1.31.0-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.src                                                 1.31.0-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.x86_64                                              1.31.0-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.aarch64                                             1.31.1-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.ppc64le                                             1.31.1-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.s390x                                               1.31.1-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.src                                                 1.31.1-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.x86_64                                              1.31.1-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.aarch64                                             1.31.2-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.ppc64le                                             1.31.2-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.s390x                                               1.31.2-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.src                                                 1.31.2-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.x86_64                                              1.31.2-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.aarch64                                             1.31.3-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.ppc64le                                             1.31.3-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.s390x                                               1.31.3-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.src                                                 1.31.3-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.x86_64                                              1.31.3-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.aarch64                                             1.31.4-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.ppc64le                                             1.31.4-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.s390x                                               1.31.4-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.src                                                 1.31.4-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.x86_64                                              1.31.4-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.aarch64                                             1.34.1-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.ppc64le                                             1.34.1-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.s390x                                               1.34.1-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.src                                                 1.34.1-150500.1.1                                         kubernetes </span><br><span class="line">kubeadm.x86_64                                              1.34.1-150500.1.1                                         kubernetes </span><br><span class="line">[root@k8s-control-plane-01 ~]#</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>控制面节点安装kubeadm组件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y kubeadm-<span class="string">&#x27;1.34.1-*&#x27;</span> kubelet-1.34.1-* kubectl-1.34.1-* --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>工作面节点安装kubeadm组件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y kubeadm-<span class="string">&#x27;1.34.1-*&#x27;</span> kubelet-1.34.1-* --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure>


<h2 id="第二步：创建kubernetes集群"><a href="#第二步：创建kubernetes集群" class="headerlink" title="第二步：创建kubernetes集群"></a>第二步：创建kubernetes集群</h2><h3 id="在-k8s-control-plane-01-节点上初始化"><a href="#在-k8s-control-plane-01-节点上初始化" class="headerlink" title="在 k8s-control-plane-01 节点上初始化"></a>在 k8s-control-plane-01 节点上初始化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-control-plane-01 ~]# kubeadm init --node-name k8s-control-plane-01 \</span><br><span class="line">    --service-cidr 10.96.0.0/12 \</span><br><span class="line">    --pod-network-cidr 10.80.0.0/12 \</span><br><span class="line">    --control-plane-endpoint 172.17.2.10:8443 \</span><br><span class="line">    --cri-socket unix:///var/run/cri-dockerd.sock \</span><br><span class="line">    --upload-certs</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now <span class="built_in">join</span> any number of control-plane nodes running the following <span class="built_in">command</span> on each as root:</span><br><span class="line"></span><br><span class="line">  kubeadm <span class="built_in">join</span> 172.17.2.10:8443 --token eli0rn.963wwi7jzx4ethmb \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4c13575009d67012f374fec49707d5d219f37fbfa02e92bb77b387362f9eee11 \</span><br><span class="line">    --control-plane --certificate-key 23bc21c88d26454f04ebf221f46723173d844327982d7e00cbc47cee4a9168ec \</span><br><span class="line">    --cri-socket unix:///var/run/cri-dockerd.sock</span><br><span class="line"></span><br><span class="line">Please note that the certificate-key gives access to cluster sensitive data, keep it secret!</span><br><span class="line">As a safeguard, uploaded-certs will be deleted <span class="keyword">in</span> two hours; If necessary, you can use</span><br><span class="line"><span class="string">&quot;kubeadm init phase upload-certs --upload-certs&quot;</span> to reload certs afterward.</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 172.17.2.10:8443 --token eli0rn.963wwi7jzx4ethmb \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4c13575009d67012f374fec49707d5d219f37fbfa02e92bb77b387362f9eee11 \</span><br><span class="line">    --cri-socket unix:///var/run/cri-dockerd.sock</span><br><span class="line"></span><br><span class="line">[root@k8s-control-plane-01 ~]# </span><br><span class="line">[root@k8s-control-plane-01 ~]# <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube &amp;&amp; <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config &amp;&amp; <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<h3 id="加入集群过程中遇见问题，如何重置节点，重新配置？"><a href="#加入集群过程中遇见问题，如何重置节点，重新配置？" class="headerlink" title="加入集群过程中遇见问题，如何重置节点，重新配置？"></a>加入集群过程中遇见问题，如何重置节点，重新配置？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm reset --cri-socket=unix:///var/run/cri-dockerd.sock</span><br><span class="line"><span class="built_in">rm</span> -rf /etc/cni/net.d</span><br><span class="line">ipvsadm --clear</span><br><span class="line"><span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span>/.kube/config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<ul>
<li>执行上面这个脚本内容，即可清除内容，重新尝试加入集群。</li>
</ul>
<h3 id="k8s-control-plane-02-节点上加入集群"><a href="#k8s-control-plane-02-节点上加入集群" class="headerlink" title="k8s-control-plane-02 节点上加入集群"></a>k8s-control-plane-02 节点上加入集群</h3><ol>
<li>从 k8s-control-plane-01 节点上复制 &#x2F;etc&#x2F;kubernetes&#x2F;pki 文件夹的ca证书到 k8s-control-plane-02 节点</li>
</ol>
<p>  需要的是ca证书，用于生成客户端证书，不是ca证书的就不需要复制了。 具体参考 pki 文件夹内的文件。</p>
<ol start="2">
<li>执行join命令加入集群</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 172.17.1.150:8443 --token a48275.0alswos0az0f4zla \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:189d94490029faeb388ca098f9b78a6debb021e4852f082e58a69497ba7c05d7 \</span><br><span class="line">    --control-plane \</span><br><span class="line">    --cri-socket unix:///var/run/cri-dockerd.sock</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube &amp;&amp; <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config &amp;&amp; <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<h3 id="k8s-control-plane-03-节点上加入集群"><a href="#k8s-control-plane-03-节点上加入集群" class="headerlink" title="k8s-control-plane-03 节点上加入集群"></a>k8s-control-plane-03 节点上加入集群</h3><ol>
<li>从 k8s-control-plane-01 节点上复制 &#x2F;etc&#x2F;kubernetes&#x2F;pki 文件夹的ca证书到 k8s-control-plane-03 节点</li>
</ol>
<p>  需要的是ca证书，用于生成客户端证书，不是ca证书的就不需要复制了。 具体参考 pki 文件夹内的文件。</p>
<ol start="2">
<li>执行join命令加入集群</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 172.17.1.150:8443 --token a48275.0alswos0az0f4zla \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:189d94490029faeb388ca098f9b78a6debb021e4852f082e58a69497ba7c05d7 \</span><br><span class="line">    --control-plane \</span><br><span class="line">    --cri-socket unix:///var/run/cri-dockerd.sock</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube &amp;&amp; <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config &amp;&amp; <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>


<h3 id="在-k8s-worker-01-节点上加入集群"><a href="#在-k8s-worker-01-节点上加入集群" class="headerlink" title="在 k8s-worker-01 节点上加入集群"></a>在 k8s-worker-01 节点上加入集群</h3><ol>
<li>执行join命令加入集群</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 172.17.1.150:8443 --token a48275.0alswos0az0f4zla \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:189d94490029faeb388ca098f9b78a6debb021e4852f082e58a69497ba7c05d7 \</span><br><span class="line">    --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<h3 id="在-k8s-worker-02-节点上加入集群"><a href="#在-k8s-worker-02-节点上加入集群" class="headerlink" title="在 k8s-worker-02 节点上加入集群"></a>在 k8s-worker-02 节点上加入集群</h3><ol>
<li>执行join命令加入集群</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 172.17.1.150:8443 --token a48275.0alswos0az0f4zla \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:189d94490029faeb388ca098f9b78a6debb021e4852f082e58a69497ba7c05d7 \</span><br><span class="line">    --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<h3 id="在-k8s-worker-03-节点上加入集群"><a href="#在-k8s-worker-03-节点上加入集群" class="headerlink" title="在 k8s-worker-03 节点上加入集群"></a>在 k8s-worker-03 节点上加入集群</h3><ol>
<li>执行join命令加入集群</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 172.17.1.150:8443 --token a48275.0alswos0az0f4zla \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:189d94490029faeb388ca098f9b78a6debb021e4852f082e58a69497ba7c05d7 \</span><br><span class="line">    --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<h3 id="在-k8s-worker-04-节点上加入集群"><a href="#在-k8s-worker-04-节点上加入集群" class="headerlink" title="在 k8s-worker-04 节点上加入集群"></a>在 k8s-worker-04 节点上加入集群</h3><ol>
<li>执行join命令加入集群</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 172.17.1.150:8443 --token a48275.0alswos0az0f4zla \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:189d94490029faeb388ca098f9b78a6debb021e4852f082e58a69497ba7c05d7 \</span><br><span class="line">    --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<h3 id="在-k8s-worker-05-节点上加入集群"><a href="#在-k8s-worker-05-节点上加入集群" class="headerlink" title="在 k8s-worker-05 节点上加入集群"></a>在 k8s-worker-05 节点上加入集群</h3><ol>
<li>执行join命令加入集群</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 172.17.1.150:8443 --token a48275.0alswos0az0f4zla \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:189d94490029faeb388ca098f9b78a6debb021e4852f082e58a69497ba7c05d7 \</span><br><span class="line">    --cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>


<h2 id="第三步：-创建flannel网络"><a href="#第三步：-创建flannel网络" class="headerlink" title="第三步： 创建flannel网络"></a>第三步： 创建flannel网络</h2><ol>
<li>在控制面节点上执行yml文件，创建flannel网络</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f kube-flannel-v0.27.4.yml</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">https://github.com/flannel-io/flannel</span><br><span class="line"></span><br><span class="line">https://github.com/flannel-io/flannel/releases/tag/v0.27.4</span><br><span class="line"></span><br><span class="line"># 在Release直接下载  kube-flannel.yml 就好， 下载之后需要配置集群Pod网络段。</span><br></pre></td></tr></table></figure>

<p>修改 kube-flannel.yml 文件，配置集群Pod网络段为 <code>10.80.0.0/12</code> ，然后就可以 <code>kubectl apply</code>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">net-conf.json<span class="punctuation">:</span> |</span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.80.0.0/12&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;EnableNFTables&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Backend&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vxlan&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>等待大概一分钟左右， 所有的集群节点会变成Ready状态。</li>
</ol>
<ul>
<li>只要 kube-flannel 部署的没什么问题，集群节点相同连通，集群节点会变成Ready状态。</li>
<li>想要 kube-flannel 部署正常，一定要开机加载前面文章提到的那些内核模块，否则即使集群处于Ready状态，后续部署服务还是会有问题。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-control-plane-01 ~]# kubectl get nodes</span><br><span class="line">NAME                   STATUS   ROLES           AGE    VERSION</span><br><span class="line">k8s-control-plane-01   Ready    control-plane   113m   v1.31.4</span><br><span class="line">k8s-control-plane-02   Ready    control-plane   109m   v1.31.4</span><br><span class="line">k8s-control-plane-03   Ready    control-plane   104m   v1.31.4</span><br><span class="line">k8s-worker-01          Ready    &lt;none&gt;          101m   v1.31.4</span><br><span class="line">k8s-worker-02          Ready    &lt;none&gt;          98m    v1.31.4</span><br><span class="line">k8s-worker-03          Ready    &lt;none&gt;          98m    v1.31.4</span><br><span class="line">k8s-worker-04          Ready    &lt;none&gt;          98m    v1.31.4</span><br><span class="line">k8s-worker-05          Ready    &lt;none&gt;          98m    v1.31.4</span><br><span class="line">[root@k8s-control-plane-01 ~]#</span><br></pre></td></tr></table></figure>

<h2 id="第四步：注意kubeadm的坑点"><a href="#第四步：注意kubeadm的坑点" class="headerlink" title="第四步：注意kubeadm的坑点"></a>第四步：注意kubeadm的坑点</h2><h3 id="1-kubeadm-证书有效期为一年，证书失效后，所有的kubeadm服务会无法启动，需要手动生成kubelet客户端证书"><a href="#1-kubeadm-证书有效期为一年，证书失效后，所有的kubeadm服务会无法启动，需要手动生成kubelet客户端证书" class="headerlink" title="1. kubeadm 证书有效期为一年，证书失效后，所有的kubeadm服务会无法启动，需要手动生成kubelet客户端证书"></a>1. kubeadm 证书有效期为一年，证书失效后，所有的kubeadm服务会无法启动，需要手动生成kubelet客户端证书</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查证书有效期</span></span><br><span class="line">kubeadm certs check-expiration</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>（六）安装Kuboard作为Kubernetes集群管理面板</title>
    <url>/posts/6a12d84a.html</url>
    <content><![CDATA[<h1 id="（六）安装Kuboard作为Kubernetes集群管理面板"><a href="#（六）安装Kuboard作为Kubernetes集群管理面板" class="headerlink" title="（六）安装Kuboard作为Kubernetes集群管理面板"></a>（六）安装Kuboard作为Kubernetes集群管理面板</h1><p>因为此次部署的Kubernetes集群是 v1.34.1，因此我们使用 Kuboard V4 进行部署。</p>
<h2 id="部署-Kuboard-V4-版本"><a href="#部署-Kuboard-V4-版本" class="headerlink" title="部署 Kuboard V4 版本"></a>部署 Kuboard V4 版本</h2><p>1、官网快速开始文档</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">https://kuboard.cn/v4/install/quickstart.html</span><br><span class="line"></span><br><span class="line"># 好好看这一页文档</span><br></pre></td></tr></table></figure>

<p>2、注意的点</p>
<ul>
<li>直接用 <code>docker-compose.yaml</code> 一键部署就完事了。</li>
<li><code>docker-compose.yaml</code> 的内容直接使用 快速开始 部分提供的就好。</li>
<li>复制一下控制面节点的 kubeconfig 文件，Kuboard 使用这个文件导入Kubernetes集群。</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>（七）安装NFS作为Kubernetes集群的存储</title>
    <url>/posts/b20ec78b.html</url>
    <content><![CDATA[<h1 id="（七）安装NFS作为Kubernetes集群的存储"><a href="#（七）安装NFS作为Kubernetes集群的存储" class="headerlink" title="（七）安装NFS作为Kubernetes集群的存储"></a>（七）安装NFS作为Kubernetes集群的存储</h1><ul>
<li>安装NFS，配置存储类之后，记得要指定默认存储类，不然某些应用无法正常部署运行。</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>（八）安装ingress-nginx作为Ingress控制器</title>
    <url>/posts/2bfeb460.html</url>
    <content><![CDATA[<h1 id="（八）安装ingress-nginx作为Ingress控制器"><a href="#（八）安装ingress-nginx作为Ingress控制器" class="headerlink" title="（八）安装ingress-nginx作为Ingress控制器"></a>（八）安装ingress-nginx作为Ingress控制器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://artifacthub.io/packages/helm/ingress-nginx/ingress-nginx</span><br></pre></td></tr></table></figure>

<h2 id="使用helm进行安装即可"><a href="#使用helm进行安装即可" class="headerlink" title="使用helm进行安装即可"></a>使用helm进行安装即可</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># shellcheck disable=SC1000-SC9999</span><br><span class="line">set -euo pipefail</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 安装 ingress-nginx</span><br><span class="line">helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx</span><br><span class="line">helm repo update</span><br><span class="line"></span><br><span class="line">helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx --namespace ingress-nginx --create-namespace --version 4.12.8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 在k8s集群有负载均衡器的前提下，ingress-nginx会得到一个自由分配的IP地址作为入口， </span><br><span class="line"># 但是自由分配的IP地址，随着服务的重启，是会变化的，你应该在service yaml文件里面，手动指定一个固定IP地址</span><br><span class="line"># 在 namespace/ingress-nginx/service里面，找到  ingress-nginx-controller 服务</span><br><span class="line"># 给 ingress-nginx-controller 服务，设置一个固定的IP地址，作为 ingress-nginx 的入口访问IP地址</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>（九）管理配置Kubernetes集群</title>
    <url>/posts/e1891b63.html</url>
    <content><![CDATA[<h1 id="（九）管理配置Kubernetes集群"><a href="#（九）管理配置Kubernetes集群" class="headerlink" title="（九）管理配置Kubernetes集群"></a>（九）管理配置Kubernetes集群</h1><h2 id="集群节点打标签"><a href="#集群节点打标签" class="headerlink" title="集群节点打标签"></a>集群节点打标签</h2><h2 id="命名空间创建"><a href="#命名空间创建" class="headerlink" title="命名空间创建"></a>命名空间创建</h2><h2 id="集群用户授权管理"><a href="#集群用户授权管理" class="headerlink" title="集群用户授权管理"></a>集群用户授权管理</h2>]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>（十一）自己动手编写Helm Charts在集群上部署应用</title>
    <url>/posts/47b0ec5d.html</url>
    <content><![CDATA[<h1 id="（十一）自己动手编写Helm-Charts在集群上部署应用"><a href="#（十一）自己动手编写Helm-Charts在集群上部署应用" class="headerlink" title="（十一）自己动手编写Helm Charts在集群上部署应用"></a>（十一）自己动手编写Helm Charts在集群上部署应用</h1>]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>（十）安装Kubernetes集群客户端工具</title>
    <url>/posts/291ede0b.html</url>
    <content><![CDATA[<h1 id="（十）安装Kubernetes集群客户端工具"><a href="#（十）安装Kubernetes集群客户端工具" class="headerlink" title="（十）安装Kubernetes集群客户端工具"></a>（十）安装Kubernetes集群客户端工具</h1><h2 id="安装-kubectl"><a href="#安装-kubectl" class="headerlink" title="安装 kubectl"></a>安装 kubectl</h2><h2 id="安装-helm"><a href="#安装-helm" class="headerlink" title="安装 helm"></a>安装 helm</h2>]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Kubeadm部署集群</category>
      </categories>
  </entry>
  <entry>
    <title>left join 与 right join 的区别</title>
    <url>/posts/2f205457.html</url>
    <content><![CDATA[<h2 id="left-join-与-right-join-的区别"><a href="#left-join-与-right-join-的区别" class="headerlink" title="left join 与 right join 的区别"></a>left join 与 right join 的区别</h2><h2 id="一、建表-SQL-Server"><a href="#一、建表-SQL-Server" class="headerlink" title="一、建表 (SQL Server)"></a>一、建表 (SQL Server)</h2><ol>
<li>创建 j1 表</li>
</ol>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db1</span><br><span class="line">go</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> dbo.j1</span><br><span class="line">(</span><br><span class="line">  id  <span class="type">int</span> <span class="keyword">not null</span>,</span><br><span class="line">  name <span class="type">varchar</span></span><br><span class="line">)</span><br><span class="line">go </span><br></pre></td></tr></table></figure>

<p>表中数据：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">a</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">b</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">c</td>
</tr>
</tbody></table>
<ol start="2">
<li>创建 j2 表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db1</span><br><span class="line">go</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> dbo.j2</span><br><span class="line">(</span><br><span class="line">  id  <span class="type">int</span> <span class="keyword">not null</span>,</span><br><span class="line">  name <span class="type">varchar</span></span><br><span class="line">)</span><br><span class="line">go</span><br></pre></td></tr></table></figure>

<p>表中数据：</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2</td>
<td align="left">q</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">w</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">e</td>
</tr>
</tbody></table>
<h3 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h3><ol>
<li>j1  left join  j2</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> j1.id <span class="keyword">as</span> j1id, j1.name <span class="keyword">as</span> j1name, j2.id <span class="keyword">as</span> j2id, j2.name <span class="keyword">as</span> j2name</span><br><span class="line"><span class="keyword">from</span> j1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> j2 <span class="keyword">on</span> j1.id <span class="operator">=</span> j2.id;</span><br></pre></td></tr></table></figure>

<p>left join 结果:</p>
<table>
<thead>
<tr>
<th align="left">j1id</th>
<th align="left">j1name</th>
<th align="left">j2id</th>
<th align="left">j2name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">a</td>
<td align="left">null</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">b</td>
<td align="left">2</td>
<td align="left">q</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">b</td>
<td align="left">2</td>
<td align="left">e</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">c</td>
<td align="left">3</td>
<td align="left">w</td>
</tr>
</tbody></table>
<ol start="2">
<li>j1  right join  j2</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> j1.id <span class="keyword">as</span> j1id, j1.name <span class="keyword">as</span> j1name, j2.id <span class="keyword">as</span> j2id, j2.name <span class="keyword">as</span> j2name</span><br><span class="line"><span class="keyword">from</span> j1</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> j2 <span class="keyword">on</span> j1.id <span class="operator">=</span> j2.id;</span><br></pre></td></tr></table></figure>

<p>right join 结果:</p>
<table>
<thead>
<tr>
<th align="left">j1id</th>
<th align="left">j1name</th>
<th align="left">j2id</th>
<th align="left">j2name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2</td>
<td align="left">b</td>
<td align="left">2</td>
<td align="left">q</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">c</td>
<td align="left">3</td>
<td align="left">w</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">b</td>
<td align="left">2</td>
<td align="left">e</td>
</tr>
</tbody></table>
<p>可以看出区别在于 id为1的记录。</p>
<ul>
<li>j1  left join  j2 时， 以 j1 为主表， id为1的记录会显示在 join 结果中</li>
<li>j1  right join  j2 时，以 j2 为主表， j2中不包含 id为1的记录， 因此id为1的记录不会显示在 join 结果中。</li>
</ul>
<p>总结：  left join 的结果  跟 right join 的结果，其记录数量是不相同的。 具体结果需要具体分析。</p>
]]></content>
      <categories>
        <category>关系数据库</category>
      </categories>
  </entry>
  <entry>
    <title>02-广度优先搜索</title>
    <url>/posts/481f2f31.html</url>
    <content><![CDATA[<h2 id="我的疑问"><a href="#我的疑问" class="headerlink" title="我的疑问"></a>我的疑问</h2><p>1、何为搜索？</p>
<p>搜索，也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。</p>
<p>2、有哪些搜索算法？</p>
<ul>
<li>二分搜索</li>
<li>深度优先搜索 （图论中的基础算法）</li>
<li>广度优先搜索 （图论中的基础算法）</li>
<li>回溯        （一种搜索技巧，用在BFS和DFS之中）</li>
</ul>
<p>3、这些搜索算法有什么特点？</p>
<p>4、如何优化搜索算法？<br>搜索有很多优化方式，如：</p>
<ul>
<li>减小状态空间</li>
<li>更改搜索顺序</li>
<li>剪枝</li>
</ul>
<p>5、广度优先搜索可以应用在哪些数据结构上面？</p>
<p>6、深度优先搜索可以应用在哪些数据结构上面？</p>
]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>01-扫描线</title>
    <url>/posts/d3875a68.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>03-深度优先搜索</title>
    <url>/posts/a658c728.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>05-分治法</title>
    <url>/posts/15504684.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>04-二分搜索</title>
    <url>/posts/be3adec0.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>07-单调队列</title>
    <url>/posts/831cfcb9.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>06-单调栈</title>
    <url>/posts/e5d867a7.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>09-排序</title>
    <url>/posts/e956d1fd.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>08-滑动窗口</title>
    <url>/posts/970be15.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>11-双指针</title>
    <url>/posts/d0b050c7.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>13-枚举</title>
    <url>/posts/a8936e94.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>14-穷举</title>
    <url>/posts/2853a75d.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>12-差分</title>
    <url>/posts/a7b3da7d.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>开发技术</title>
    <url>/posts/8ee9a54a.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>系列文章</category>
      </categories>
  </entry>
  <entry>
    <title>教育教学</title>
    <url>/posts/56a16bf9.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>系列文章</category>
      </categories>
  </entry>
  <entry>
    <title>10-前缀和</title>
    <url>/posts/88fbe3d3.html</url>
    <content><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="对前缀和的理解"><a href="#对前缀和的理解" class="headerlink" title="对前缀和的理解"></a>对前缀和的理解</h2><ul>
<li>前缀和：用于快速求区间和。</li>
<li>差分： 用于高效进行区间修改。</li>
</ul>
<p>前缀和是数列的前<code>n</code>项的和， 它是用来预处理的一种方式。</p>
<h1 id="涉及到的数学知识"><a href="#涉及到的数学知识" class="headerlink" title="涉及到的数学知识"></a>涉及到的数学知识</h1><h2 id="1、同余定理-（此概念来自数论）"><a href="#1、同余定理-（此概念来自数论）" class="headerlink" title="1、同余定理  （此概念来自数论）"></a>1、同余定理  （此概念来自数论）</h2><h3 id="同余定义"><a href="#同余定义" class="headerlink" title="同余定义"></a>同余定义</h3><p>对于两个整数a，b，若它们除以正整数 m 所得的余数相等，则称 a，b 对于模 m 同余。严格来说，存在一个整数 k 使得  <code>a - b = k * m</code>，则称 a , b 对于除数 m 是同余的。一般记做  <code>a ≡ b (mod m)</code> 。</p>
<p>比如 <code>26 -14 = 12 = 1 * 12</code>， 可以记作 <code>26 ≡ 14 (mod 12)</code></p>
<h3 id="同余性质"><a href="#同余性质" class="headerlink" title="同余性质"></a>同余性质</h3><ul>
<li>反身性：a≡a (mod m)</li>
<li>对称性： 若a≡b(mod m)，则b≡a(mod m)</li>
<li>传递性： 若a≡b(mod m)，b≡c(mod m)，则a≡c(mod m)</li>
<li>同余式相加：若a≡b(mod m)，b≡c(mod m)，则a ± c≡b ± d(mod m)</li>
<li>同余式相乘：若a≡b(mod m)，b≡c(mod m)，则ac≡bd(mod m)</li>
<li>线性运算：如果a≡b(mod m)，c≡d(mod m)，那么a ± c≡b ± d(mod m)，且a * c≡b * d(mod m)</li>
<li>除法：若ac ≡ bc (mod m) c≠0 则 a≡ b (mod m&#x2F;gcd(c,m)) 其中gcd(c,m)表示c,m的最大公约数。特殊地 ,gcd(c,m)&#x3D;1 则a ≡ b (mod m)</li>
<li>幂运算：如果a ≡ b (mod m)，那么a^n ≡ b^n (mod m)</li>
<li>若a ≡ b (mod m)，n|m,则 a ≡ b (mod n)</li>
<li>若a ≡ b (mod mi) (i&#x3D;1,2…n) 则 a ≡ b (mod [m1,m2,…mn]) 其中[m1,m2,…mn]表示m1,m2,…mn的最小公倍数.</li>
</ul>
]]></content>
      <categories>
        <category>算法学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>Windows删除流氓文件夹</title>
    <url>/posts/b9938b09.html</url>
    <content><![CDATA[<h2 id="Windows删除流氓文件夹"><a href="#Windows删除流氓文件夹" class="headerlink" title="Windows删除流氓文件夹"></a>Windows删除流氓文件夹</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>我们在使用电脑的过程中，尤其是办公，去创建一些文档，但是在删除的时候就删除不了了，系统提示“找不到该项目”，关于删除文件或者文件夹提示“找不到该项目”强删方法。</p>
<p>一个盘下面出现两个迅雷下载文件夹， 其中一个删不掉。</p>
<span id="more"></span>


<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>新建一个压缩文件，将它添加进压缩文件时勾选“压缩后删除源文件”，针对文件夹同样有效。</p>
]]></content>
      <categories>
        <category>Windows系统</category>
      </categories>
  </entry>
  <entry>
    <title>Windows软件推荐</title>
    <url>/posts/22dee00c.html</url>
    <content><![CDATA[<h1 id="Windows软件推荐"><a href="#Windows软件推荐" class="headerlink" title="Windows软件推荐"></a>Windows软件推荐</h1><h2 id="Windows图片工具推荐"><a href="#Windows图片工具推荐" class="headerlink" title="Windows图片工具推荐"></a>Windows图片工具推荐</h2><p>1、功能：查看图片</p>
<p>推荐使用 XnView MP</p>
<p>2、功能：截图与图片标注</p>
<p>推荐使用 snipaste</p>
<ul>
<li>截图标注：按F1进行截图，并进行标注。</li>
<li>现有图片标注：Ctrl+C 复制已存在的图片，按F3贴图，对贴图进行标注，然后保存为新图片。</li>
</ul>
<p>一般来讲，snipaste免费版即可满足日常使用需要。如果有更多需求，可以购买专业版，价格也不贵。</p>
<p>3、功能：录制Gif动图</p>
<p>推荐使用 ScreenToGif</p>
<p>4、如果需要复杂功能，推荐使用 PhotoShop</p>
<ul>
<li>提示：PhotoShop功能太过强大，需要专门花很多时间进行学习！</li>
</ul>
<h2 id="Windows磁盘工具推荐"><a href="#Windows磁盘工具推荐" class="headerlink" title="Windows磁盘工具推荐"></a>Windows磁盘工具推荐</h2><p>1、功能：磁盘分区、备份Windows系统、完全粉碎文件</p>
<p>推荐使用 DiskGenius</p>
<p>DiskGenius可以对C盘做磁盘镜像，从而实现备份Windows系统，这个功能很好用！</p>
<p>只要复制文件到磁盘，使用快捷键 Shift+Delete 删除文件，删除的文件是可以使用数据恢复软件恢复的。<br>如果希望彻底粉碎文件不留痕迹，可以使用DiskGenius的文件粉碎功能来删除文件。</p>
<p>2、功能：分析已使用的磁盘空间，快速找出大文件</p>
<p>推荐使用 WizTree</p>
<p>WizTree 支持按文件大小排序，可以快速分析出文件的磁盘空间占用情况。</p>
<p>3、功能：磁盘健康度监控</p>
<p>推荐使用 磁盘哨兵（HDSentinel）</p>
<p>使用磁盘哨兵监控固态硬盘、机械硬盘的健康度，定期检查，提前找出不健康的磁盘，避免单磁盘&#x2F;磁盘阵列故障导致丢失数据。</p>
<p>4、功能：弹出优盘、移动硬盘</p>
<p>推荐使用 USB Safely Remove</p>
<h2 id="Windows密码管理工具推荐"><a href="#Windows密码管理工具推荐" class="headerlink" title="Windows密码管理工具推荐"></a>Windows密码管理工具推荐</h2><p>1、功能：浏览器密码管理</p>
<p>推荐使用：KeepassXC，官网是 <code>https://keepassxc.org/</code></p>
<p>KeepassXC有浏览器拓展，支持Edge、Chrome、FIrefox，可以避免在浏览器重复手动输入密码。</p>
<h2 id="Windows剪贴板工具推荐"><a href="#Windows剪贴板工具推荐" class="headerlink" title="Windows剪贴板工具推荐"></a>Windows剪贴板工具推荐</h2><p>1、Windows系统提供的剪贴板工具</p>
<p>按快捷键 Windows建 + V 可以弹出剪贴板窗口</p>
<p>2、第三方剪贴板工具</p>
<p>推荐使用：CopyQ</p>
<h2 id="Windows系统清理工具推荐"><a href="#Windows系统清理工具推荐" class="headerlink" title="Windows系统清理工具推荐"></a>Windows系统清理工具推荐</h2><p>1、功能：清理系统垃圾、C盘瘦身、清理注册表</p>
<p>推荐使用：Dism++、HDCleaner</p>
<p>不要使用CCleaner破解版，可以使用HDCleaner替代。</p>
<p>破解版问题是，虽然没有病毒，但是它的目的是偷你的Cookie、信用卡信息，这才是破解版害人的地方。</p>
<p>2、功能：卸载Windows软件</p>
<p>推荐使用：Geek Uninstaller</p>
<h2 id="Windows右键菜单工具推荐"><a href="#Windows右键菜单工具推荐" class="headerlink" title="Windows右键菜单工具推荐"></a>Windows右键菜单工具推荐</h2><p>Windows11的右键显示风格不好用，自己在网上找教程，切换回Windows10的右键显示风格。</p>
<p>搜索关键词： win11右键菜单改回win10</p>
<p>1、火绒自带的右键菜单管理功能</p>
<p>2、Dism++右键菜单管理功能</p>
<p>3、ContextMenuManager Windows右键管理</p>
<p>Github地址是 <code>https://github.com/BluePointLilac/ContextMenuManager</code></p>
<h2 id="Windows快捷方式工具推荐"><a href="#Windows快捷方式工具推荐" class="headerlink" title="Windows快捷方式工具推荐"></a>Windows快捷方式工具推荐</h2><p>1、功能：软件启动快捷方式面板</p>
<p>推荐使用：CLaunch</p>
<p>Windwos10的全屏开始菜单被砍掉了，Windows11开始菜单可以固定的快捷方式数量太少。</p>
<p>Windows11支持把软件快捷方式固定到任务栏、固定开始菜单，但是这两个地方可以固定的数量非常有限。<br>一旦你的快捷方式数量超过限制值，就没有地方放了，这时候就需要快捷方式面板来存放快捷方式。</p>
<h2 id="Windows电子书工具推荐"><a href="#Windows电子书工具推荐" class="headerlink" title="Windows电子书工具推荐"></a>Windows电子书工具推荐</h2><p>1、功能：阅读PDF文件</p>
<p>推荐使用 文电通PDF阅读器，官网是 <code>https://www.rightpdf.cn/zh-CN</code></p>
<p>2、功能：阅读 epub、azw3，mobi 电子书</p>
<p>推荐使用 Neat Reader ，官网是：<code>https://neat-reader.cn/</code></p>
<p>3、功能：编辑 epub、azw3，mobi 电子书</p>
<p>推荐使用 Calibre</p>
<p>4、功能：在线下载电子书</p>
<p>推荐使用的在线下载网站：Zlib、安娜档案</p>
<p>访问这些网站，需要你可以科学上网。</p>
<h2 id="Windows文档编写工具推荐"><a href="#Windows文档编写工具推荐" class="headerlink" title="Windows文档编写工具推荐"></a>Windows文档编写工具推荐</h2><p>1、功能：编辑预览Markdown文件</p>
<p>推荐使用：VSCode</p>
<p>使用 VSCode 的插件实现Markdown文件编辑于预览。</p>
<p>推荐使用的 VSCode 字体： <code>&#39;Fira Mono Medium&#39;,&#39;LXGW WenKai Mono Medium&#39;</code>，字体大小14</p>
<h2 id="Windows图表工具推荐"><a href="#Windows图表工具推荐" class="headerlink" title="Windows图表工具推荐"></a>Windows图表工具推荐</h2><p>1、功能：绘制各种图表</p>
<p>推荐使用：drawio-desktop</p>
<p>2、功能：绘制思维导图</p>
<p>推荐使用：Xmind、freeplane、思绪思维导图</p>
<h2 id="Windows白板工具推荐"><a href="#Windows白板工具推荐" class="headerlink" title="Windows白板工具推荐"></a>Windows白板工具推荐</h2>]]></content>
      <categories>
        <category>Windows系统</category>
      </categories>
  </entry>
  <entry>
    <title>Linux系统安装字体</title>
    <url>/posts/15d565a7.html</url>
    <content><![CDATA[<h2 id="字体文件存放目录"><a href="#字体文件存放目录" class="headerlink" title="字体文件存放目录"></a>字体文件存放目录</h2><p>1、系统级别的字体目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/share/fonts</span><br></pre></td></tr></table></figure>

<p>字体文件放在此目录下，所有用户都可以使用该字体。</p>
<p>2、用户级别的字体目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/.fonts</span><br></pre></td></tr></table></figure>

<p>字体文件放在此目录下，只有当前用户才能使用该字体。</p>
<h2 id="字体安装方法"><a href="#字体安装方法" class="headerlink" title="字体安装方法"></a>字体安装方法</h2><p>1、在字体文件存放目录下，新建一个文件夹，把字体文件复制到新建文件夹下</p>
<p>2、执行命令生成字体缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fc-cache -f -v</span><br></pre></td></tr></table></figure>

<h2 id="查看字体"><a href="#查看字体" class="headerlink" title="查看字体"></a>查看字体</h2><p>1、通过 <code>fc-list</code> 命令进行查看</p>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
  </entry>
  <entry>
    <title>VMware Workstation Pro 虚拟机常用配置</title>
    <url>/posts/5037e810.html</url>
    <content><![CDATA[<h1 id="VMware-Workstation-Pro-虚拟机常用配置"><a href="#VMware-Workstation-Pro-虚拟机常用配置" class="headerlink" title="VMware Workstation Pro 虚拟机常用配置"></a>VMware Workstation Pro 虚拟机常用配置</h1><p>1、虚拟机没有磁盘UUID怎么办？</p>
<p>编辑虚拟机vmx文件，加入下列配置项即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disk.EnableUUID = &quot;TRUE&quot;</span><br></pre></td></tr></table></figure>

<p>2、如何禁用vmem文件？</p>
<p>使用 VMWare 虚拟机，虚拟机启动后，会在虚拟机目录下建立一个与虚拟内存大小相同的.vmem文件。这个文件主要是将虚拟机内存的内容映射到磁盘，以支持在虚拟机的暂停等功能。但关闭也是支持暂停功能的，平时还不这么频繁读写磁盘。</p>
<p>编辑虚拟机vmx文件，加入下列配置项即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mainMem.useNamedFile = &quot;FALSE&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>虚拟化技术</category>
        <category>VMwareWorkstationPro</category>
      </categories>
  </entry>
  <entry>
    <title>VMware Workstation Pro 虚拟机回收磁盘空间</title>
    <url>/posts/6c0c2176.html</url>
    <content><![CDATA[<h2 id="Windows虚拟机"><a href="#Windows虚拟机" class="headerlink" title="Windows虚拟机"></a>Windows虚拟机</h2><p>对于 Windows 虚拟机，可以选中虚拟机右键，管理选项，选择清理磁盘。这种方式回收空间速度很快，使用起来非常方便。</p>
<p>真正让人头疼的是Linux虚拟机，VMware Workstation Pro 不支持trim，文件删除后，空间还是占用着，无法回收。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@pve:~# <span class="comment"># vmware workstation Pro 虚拟磁盘不支持trim</span></span><br><span class="line">root@pve:~# fstrim -v /</span><br><span class="line">fstrim: /: the discard operation is not supported</span><br><span class="line">root@pve:~# </span><br></pre></td></tr></table></figure>


<h2 id="Linux虚拟机"><a href="#Linux虚拟机" class="headerlink" title="Linux虚拟机"></a>Linux虚拟机</h2><h3 id="使用vmtools提供的shrink功能回收磁盘空间"><a href="#使用vmtools提供的shrink功能回收磁盘空间" class="headerlink" title="使用vmtools提供的shrink功能回收磁盘空间"></a>使用vmtools提供的shrink功能回收磁盘空间</h3><p>第一步、虚拟机安装vmtools</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install open-vm-tools</span><br><span class="line"></span><br><span class="line">dnf install open-vm-tools</span><br></pre></td></tr></table></figure>

<p>第二步、查看可压缩磁盘的挂载点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@pve:~# vmware-toolbox-cmd disk list</span><br><span class="line">/</span><br><span class="line">/storage</span><br><span class="line">root@pve:~#</span><br></pre></td></tr></table></figure>

<p>第三步、压缩磁盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@pve:~# <span class="comment"># 注意：先wipe，再shrink</span></span><br><span class="line">root@pve:~# vmware-toolbox-cmd disk wipe /</span><br><span class="line">root@pve:~# vmware-toolbox-cmd disk shrink /</span><br></pre></td></tr></table></figure>

<p><code>wipe/shrink</code>功能对于Linux磁盘的限制：</p>
<ul>
<li>1、<code>wipe/shrink</code> 功能不支持LVM磁盘。<ul>
<li>不要在虚拟机上使用LVM技术拼接多块虚拟磁盘，这会导致无法回收，磁盘占用越来越大。</li>
<li>应该使用单块虚拟磁盘，一块虚拟磁盘对应一个挂载点。格式化成 ext4 或者 xfs。</li>
</ul>
</li>
<li>3、wipe&#x2F;shrink&#96;功能需要宿主机有大量空闲的磁盘空间。<ul>
<li>如果一块虚拟机磁盘占用了300GB空间，虚拟机所在的磁盘需要有大于300GB的空闲空间，才能执行shrink命令，不然机会回收出错。</li>
<li>好消息是，一块磁盘回收出错，不影响另一块磁盘正常回收。 </li>
<li>回收磁盘的时候，要打开 VMware Workstation 打开虚拟机，不要后台运行；</li>
<li>这样回收出错时会提示你，如果一块磁盘因空间不够回收出错，你还可以进行另一块磁盘的回收。</li>
</ul>
</li>
</ul>
<h3 id="使用LVM磁盘时碰见的问题"><a href="#使用LVM磁盘时碰见的问题" class="headerlink" title="使用LVM磁盘时碰见的问题"></a>使用LVM磁盘时碰见的问题</h3><p>ProxmoxVE虚拟机，从 <code>df -lh</code> 命令看，占用400G； 但是从Windows下看，实际占用了807G，而且后期又增长到了900多GB。shrink后，从 807G 变成 704G， 也是没什么大用， 等了一个多小时，就这？还不如不做 shrink ，真真的浪费时间！这种方式很慢很慢，虚拟机越大耗时越久。 如果虚拟机占用比较小，使用shrink功能应该会比较快。</p>
<p>ProxmoxVE虚拟机有多块4TB的虚拟磁盘，使用LVM创建逻辑卷，用于存储创建的虚拟机。多块磁盘组LVM 似乎会影响到vmtools磁盘收缩，导致收缩不正常，此条存疑，是自己的怀疑。</p>
<h3 id="使用系统磁盘加数据磁盘控制使用量"><a href="#使用系统磁盘加数据磁盘控制使用量" class="headerlink" title="使用系统磁盘加数据磁盘控制使用量"></a>使用系统磁盘加数据磁盘控制使用量</h3><p>如果<code>wipe/shrink</code>功能正常，就不需要这种绕路的方案，因此不建议在开发虚拟机里面使用LVM功能，建议直接单盘挂载！</p>
<p>磁盘空间增长不释放问题，确实很烦人，这也算是没有办法的办法吧！</p>
<p>因为虚拟磁盘只能不断动态增长，虚拟机里面删了文件，也没法缩小，空间占用越来越大。使用多块小容量磁盘，不使用大容量磁盘。系统磁盘加数据磁盘的方式，可以把磁盘占用控制在可接受范围内。</p>
<p>系统磁盘用来装Linux系统，不需要太大的空间，32GB、64GB都是可以的。数据磁盘用于存放用户数据文件，可以适当大一些，256GB、512GB都是可以的；如果确定文件真的会占用大容量空间，再使用TB级别的虚拟磁盘，否则使用多块小容量磁盘去组合成大容量磁盘。</p>
<p>这样的话，最大空间容量为：</p>
<ul>
<li>系统磁盘加数据磁盘： 32GB + 256GB &#x3D; 288GB</li>
<li>系统磁盘加数据磁盘： 32GB + 512GB &#x3D; 544GB</li>
<li>系统磁盘加数据磁盘： 64GB + 256GB &#x3D; 320GB</li>
<li>系统磁盘加数据磁盘： 64GB + 512GB &#x3D; 576GB</li>
</ul>
<p>按照这种方式，即使磁盘空间一直增长不释放，也就是使用了两者相加的最大容量，这个最大容量提前计算好，可以保持在可接受范围内。如果写满了最大容量，可以再添加一块新磁盘，移动文件，替换旧磁盘。</p>
<p>1、为什么使用小容量磁盘？</p>
<p>如果单盘2T或者更大的时候，对Linux虚拟机的磁盘收缩回收空间，速度会特别慢。思考之后发现，实际上虚拟机用不了2T、4T这样的大空间，设置大空间磁盘没什么意义，大磁盘会拆分成多个文件，反而会影响速度。</p>
<p>虚拟磁盘类型选NVME，大小选择512GB，将小容量虚拟磁盘存储为单个文件。这样做的目的，是为了获得比较好的磁盘IO性能。单文件512GB也不算太大，方便移动。用作开发环境的虚拟机，真的不需要那么大的空间。关键是，如果一块不够，你还可以再加磁盘。</p>
<p>2、使用 ext4 还是 xfs ？</p>
<p>使用ext4的时候，DiskGenius Pro 可以直接读取vmdk，从里面提取文件。使用xfs的时候，DiskGenius Pro 不支持xfs文件系统，无法读取文件。使用xfs的时候，LVM逻辑卷空间只能增大，不能缩小。  UFS软件专业版可以读取xfs， 单块盘是可以读取的，但是LVM跨多盘似乎不支持。</p>
<p>3、不用LVM的原因？</p>
<p>单独一个分区，不做LVM，即使虚拟机出问题不能启动，也可以使用 DiskGenius 直接读取vmdk文件。跨多块磁盘组LVM的时候，DiskGenius 没法直接读取逻辑卷。这样的话，在不开虚拟机的情况下，没法直接读取vmdk磁盘。</p>
]]></content>
      <categories>
        <category>虚拟化技术</category>
        <category>VMwareWorkstationPro</category>
      </categories>
  </entry>
  <entry>
    <title>VMware Workstation Pro 嵌套虚拟化 ProxmoxVE</title>
    <url>/posts/ea0a45e6.html</url>
    <content><![CDATA[<h2 id="VMware安装PVE虚拟机"><a href="#VMware安装PVE虚拟机" class="headerlink" title="VMware安装PVE虚拟机"></a>VMware安装PVE虚拟机</h2><p>下载ISO安装镜像，正常安装就好。不会的话就去网上搜教程。</p>
<h3 id="虚拟磁盘创建策略"><a href="#虚拟磁盘创建策略" class="headerlink" title="虚拟磁盘创建策略"></a>虚拟磁盘创建策略</h3><p>第一块硬盘叫做 disk01.vmdk，第二块硬盘叫做 disk02.vmdk，以此类推。</p>
<p>PVE虚拟机,虚拟机名称叫 ProxmoxVE。</p>
<p>ProxmoxVE.vmdk 64GB  用于安装PVE系统，以及local存储目录，使用ext4文件系统。 删掉local-lvm这个逻辑卷，把空间全都分给local存储目录。</p>
<p>系统盘 64G ，1GB &#x2F;boot, 16GB swap分区，剩下的分给local目录，主要用于上传下载备份文件，足矣， 再大纯属浪费。</p>
<p>disk01.vmdk 512GB  用于存储PVE创建的虚拟机。 单独一个分区，不做LVM，使用ext4文件系统，挂载到 &#x2F;storage&#x2F;disk01, 对应存储目录 disk01</p>
<p>disk02.vmdk 512GB  用于存储PVE创建的虚拟机。 单独一个分区，不做LVM，使用ext4文件系统，挂载到 &#x2F;storage&#x2F;disk02, 对应存储目录 disk02</p>
<h3 id="安装需要注意的点"><a href="#安装需要注意的点" class="headerlink" title="安装需要注意的点"></a>安装需要注意的点</h3><p>1.使用lvm创建分区挂载各个挂载点，方便后期磁盘空间扩容。</p>
<p>2.虚拟机安装完成后，在虚拟机里面把vmtools装上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install open-vm-tools</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>3.虚拟机设置》处理器》虚拟化引擎，把 <code>虚拟化 Intel VT-x AMD-V</code> 和 <code>虚拟化CPU性能计数器</code> 两个选项都勾上。</p>
<ul>
<li><code>虚拟化 Intel VT-x AMD-V</code>： 必须勾选，不选这个，没法使用PVE创建运行虚拟机。</li>
<li><code>虚拟化CPU性能计数器</code>： 可以提升虚拟机CPU性能</li>
</ul>
<h3 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 基础工具</span></span><br><span class="line">apt-get install -y apt-file</span><br><span class="line">apt-get install -y vim tree unzip tar bzip2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 传感器相关</span></span><br><span class="line">apt-get install -y lm-sensors hddtemp</span><br><span class="line"></span><br><span class="line"><span class="comment">## openvswitch</span></span><br><span class="line">apt-get install -y openvswitch-switch openvswitch-common \</span><br><span class="line">    openvswitch-switch-dpdk openvswitch-ipsec openvswitch-test</span><br><span class="line"></span><br><span class="line"><span class="comment">## qemu arm aarch64</span></span><br><span class="line">apt-get install -y qemu-efi qemu-efi-arm qemu-efi-aarch64</span><br></pre></td></tr></table></figure>

<h2 id="PVE虚拟机管理"><a href="#PVE虚拟机管理" class="headerlink" title="PVE虚拟机管理"></a>PVE虚拟机管理</h2><h3 id="虚拟机常用管理命令"><a href="#虚拟机常用管理命令" class="headerlink" title="虚拟机常用管理命令"></a>虚拟机常用管理命令</h3><p>1.虚拟机解除锁定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@pve:~# qm unlock 106</span><br></pre></td></tr></table></figure>

<p>2.虚拟机打标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@pve:~# qm <span class="built_in">set</span> 121 -tags app</span><br><span class="line">update VM 121: -tags app</span><br><span class="line">root@pve:~#</span><br></pre></td></tr></table></figure>

<h3 id="虚拟机磁盘不释放"><a href="#虚拟机磁盘不释放" class="headerlink" title="虚拟机磁盘不释放"></a>虚拟机磁盘不释放</h3><ol>
<li>问题描述</li>
</ol>
<p>PVE虚拟机磁盘删除大量文件后， 磁盘空间没有释放。</p>
<ol start="2">
<li>解决方案</li>
</ol>
<p>关闭虚拟机， 在 硬件 选项里面， 双击 硬盘 ， 弹出的选项卡里面， 勾选 丢弃 。</p>
<p>开启虚拟机， ssh连上去， 执行 <code>fstrim -av</code> 命令。 命令执行成功之后， 磁盘空间就释放了。</p>
<h2 id="PVE8-导入-VMware-Workstation-Pro-虚拟机"><a href="#PVE8-导入-VMware-Workstation-Pro-虚拟机" class="headerlink" title="PVE8 导入 VMware Workstation Pro 虚拟机"></a>PVE8 导入 VMware Workstation Pro 虚拟机</h2><h3 id="第一步：VMware-Workstation-Pro-导出虚拟机"><a href="#第一步：VMware-Workstation-Pro-导出虚拟机" class="headerlink" title="第一步：VMware Workstation Pro 导出虚拟机"></a>第一步：VMware Workstation Pro 导出虚拟机</h3><p>选中虚拟机， 文件 &gt;  导出为OVF</p>
<h3 id="第二步：PVE8导入虚拟机"><a href="#第二步：PVE8导入虚拟机" class="headerlink" title="第二步：PVE8导入虚拟机"></a>第二步：PVE8导入虚拟机</h3><ol>
<li><p>把导出的ovf文件传到服务器</p>
</li>
<li><p>使用<code>qm importovf &lt;vmid&gt; &lt;ovf file&gt; &lt;storage&gt;</code> 命令导入，如： <code>qm importovf 100 exported.ovf local-lvm</code></p>
</li>
</ol>
<h3 id="第三步：虚拟机导入PVE8之后的操作"><a href="#第三步：虚拟机导入PVE8之后的操作" class="headerlink" title="第三步：虚拟机导入PVE8之后的操作"></a>第三步：虚拟机导入PVE8之后的操作</h3><ol>
<li>磁盘接口选中 IDE接口</li>
<li>重新设置虚拟机引导顺序</li>
<li>重新配置网卡接口和IP地址</li>
<li><code>CentOS7</code>配置网卡</li>
</ol>
<h2 id="PVE8虚拟机-导出到-VMware-Workstation-Pro-虚拟机"><a href="#PVE8虚拟机-导出到-VMware-Workstation-Pro-虚拟机" class="headerlink" title="PVE8虚拟机 导出到 VMware Workstation Pro 虚拟机"></a>PVE8虚拟机 导出到 VMware Workstation Pro 虚拟机</h2><h3 id="第一步-PVE8管理界面下备份虚拟机，生成备份文件"><a href="#第一步-PVE8管理界面下备份虚拟机，生成备份文件" class="headerlink" title="第一步: PVE8管理界面下备份虚拟机，生成备份文件"></a>第一步: PVE8管理界面下备份虚拟机，生成备份文件</h3><p>这里对虚拟机(Fedora Server 38) 进行了备份，生成的备份文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@pve:~# <span class="built_in">ls</span> -lh /var/lib/vz/dump/</span><br><span class="line">total 3.2G</span><br><span class="line">-rw-r--r-- 1 root root 4.3K Mar 22 17:35 vzdump-qemu-116-2024_03_22-16_03_12.log</span><br><span class="line">-rw-r--r-- 1 root root 3.2G Mar 22 17:36 vzdump-qemu-116-2024_03_22-16_03_12.vma.zst</span><br><span class="line">-rw-r--r-- 1 root root  116 Mar 22 17:35 vzdump-qemu-116-2024_03_22-16_03_12.vma.zst.notes</span><br><span class="line">root@pve:~#</span><br></pre></td></tr></table></figure>

<h3 id="第二步-格式转换，将虚拟机备份文件-vma-zst转换成vmdk格式"><a href="#第二步-格式转换，将虚拟机备份文件-vma-zst转换成vmdk格式" class="headerlink" title="第二步: 格式转换，将虚拟机备份文件*.vma.zst转换成vmdk格式"></a>第二步: 格式转换，将虚拟机备份文件<code>*.vma.zst</code>转换成<code>vmdk</code>格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@pve:~# <span class="comment"># 先解压 *.vma.zst 文件，得到 *.vma 文件</span></span><br><span class="line">root@pve:~# <span class="built_in">cd</span> /var/lib/vz/dump/</span><br><span class="line">root@pve:/var/lib/vz/dump# <span class="built_in">ls</span> *.vma.zst</span><br><span class="line">vzdump-qemu-116-2024_03_22-16_03_12.vma.zst</span><br><span class="line">root@pve:/var/lib/vz/dump#</span><br><span class="line">root@pve:/var/lib/vz/dump# zstd -d vzdump-qemu-116-2024_03_22-16_03_12.vma.zst</span><br><span class="line">vzdump-qemu-116-2024_03_22-16_03_12.vma.zst: 7025745408 bytes                  </span><br><span class="line">root@pve:/var/lib/vz/dump# <span class="built_in">ls</span> *.vma</span><br><span class="line">vzdump-qemu-116-2024_03_22-16_03_12.vma</span><br><span class="line">root@pve:/var/lib/vz/dump#</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@pve:~# <span class="comment"># 再把 *.vma 文件解压得到 *.raw 文件</span></span><br><span class="line">root@pve:/var/lib/vz/dump# vma extract vzdump-qemu-116-2024_03_22-16_03_12.vma extract</span><br><span class="line">DEVINFO extract/tmp-disk-drive-scsi0.raw 274877906944</span><br><span class="line">root@pve:/var/lib/vz/dump# <span class="built_in">ls</span> extract/*.raw</span><br><span class="line">extract/disk-drive-scsi0.raw</span><br><span class="line">root@pve:/var/lib/vz/dump#</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@pve:~# <span class="comment"># 最后用qemu-img把raw转换vmdk</span></span><br><span class="line">root@pve:/var/lib/vz/dump# <span class="built_in">cd</span> extract/</span><br><span class="line">root@pve:/var/lib/vz/dump/extract# qemu-img convert -f raw -O vmdk disk-drive-scsi0.raw disk-drive-scsi0.vmdk</span><br><span class="line">root@pve:/var/lib/vz/dump/extract# <span class="built_in">ls</span></span><br><span class="line">disk-drive-scsi0.raw  disk-drive-scsi0.vmdk  qemu-server.conf</span><br><span class="line">root@pve:/var/lib/vz/dump/extract#</span><br></pre></td></tr></table></figure>

<p>得到vmdk文件后,你可以导入VMware作为虚拟机的虚拟硬盘了。</p>
<h3 id="第三步-VMware-Workstation-Pro-创建虚拟机"><a href="#第三步-VMware-Workstation-Pro-创建虚拟机" class="headerlink" title="第三步: VMware Workstation Pro 创建虚拟机"></a>第三步: VMware Workstation Pro 创建虚拟机</h3><ol>
<li>创建一个文件夹(FedoraServer38), 把 disk-drive-scsi0.vmdk 放到这个文件夹里面， 如下：</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\VMware\FedoraServer38&gt; <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line">    Directory: E:\VMware\FedoraServer38</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line"><span class="literal">----</span>                 <span class="literal">-------------</span>         <span class="literal">------</span> <span class="literal">----</span></span><br><span class="line"><span class="literal">-a---</span>           <span class="number">2024</span>/<span class="number">3</span>/<span class="number">22</span>    <span class="number">17</span>:<span class="number">59</span>              <span class="number">0</span> disk<span class="literal">-drive-scsi0</span>.vmdk</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> E:\VMware\FedoraServer38&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>打开 VMware Workstation Pro 新建虚拟机</p>
<p> 跟正常创建虚拟机步骤一样，在新建虚拟机向导里面，需要注意的有两点：</p>
<ul>
<li>磁盘接口选类型选择IDE，一定要是IDE，不然创建的虚拟机无法正常启动。</li>
<li>到选择磁盘这一步的时候， 要选择 使用现有虚拟磁盘，找到上面文件夹里面的 disk-drive-scsi0.vmdk， 完成虚拟机的创建。</li>
</ul>
<p> 创建成功即可正常启动。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>虚拟化技术</category>
        <category>VMwareWorkstationPro</category>
      </categories>
  </entry>
  <entry>
    <title>Hyper-V 嵌套虚拟化 ProxmoxVE</title>
    <url>/posts/14798af5.html</url>
    <content><![CDATA[<h2 id="Hyper-V安装PVE"><a href="#Hyper-V安装PVE" class="headerlink" title="Hyper-V安装PVE"></a>Hyper-V安装PVE</h2><ul>
<li>不推荐使用这种方式，使用起来不太方便，推荐使用VMware安装PVE。</li>
</ul>
<h3 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h3><p>创建第二代虚拟机， 记得关掉安全启动，不然iso没法引导。</p>
<span id="more"></span>

<h3 id="开启嵌套虚拟化"><a href="#开启嵌套虚拟化" class="headerlink" title="开启嵌套虚拟化"></a>开启嵌套虚拟化</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-VMProcessor</span> <span class="literal">-ExposeVirtualizationExtensions</span> <span class="variable">$true</span> <span class="literal">-VMName</span> PVE</span><br></pre></td></tr></table></figure>


<h3 id="新建NAT网络"><a href="#新建NAT网络" class="headerlink" title="新建NAT网络"></a>新建NAT网络</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-VMProcessor</span> <span class="literal">-ExposeVirtualizationExtensions</span> <span class="variable">$true</span> <span class="literal">-VMName</span> PVE</span><br><span class="line"></span><br><span class="line"><span class="built_in">New-VMSwitch</span> <span class="literal">-SwitchName</span> <span class="string">&quot;PVE-NAT&quot;</span> <span class="literal">-SwitchType</span> Internal</span><br><span class="line"></span><br><span class="line"><span class="variable">$ifindex</span> = <span class="built_in">Get-NetAdapter</span> <span class="literal">-Name</span> <span class="string">&quot;vEthernet (PVE-NAT)&quot;</span> | <span class="built_in">Select-Object</span> <span class="literal">-ExpandProperty</span> <span class="string">&#x27;ifIndex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">New-NetIPAddress</span> <span class="literal">-IPAddress</span> <span class="number">172.17</span>.<span class="number">0.2</span> <span class="literal">-PrefixLength</span> <span class="number">16</span> <span class="literal">-InterfaceIndex</span> <span class="variable">$ifindex</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">New-NetNat</span> <span class="literal">-Name</span> PVE<span class="literal">-NAT</span> <span class="literal">-InternalIPInterfaceAddressPrefix</span> <span class="number">172.17</span>.<span class="number">0.2</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>关于Nat网络，在已经安装了 VMware workstation 的时候，其实不用重新创建。</p>
<p>在 Hyper-V 里面创建一个虚拟网络交换机，使用外部网络， 选中 VMware workstation 已经创建好的 VMnet8 就行了。 </p>
<p>这样 Hyper-V 创建的虚拟机就可以跟 VMware workstation 创建的虚拟机相互通信。 这是最便捷的方式了。</p>
<p>如果外部局域网想要访问 VMnet8 里面的虚拟机，再创建一个虚拟网络交换机，使用外部网络，选择局域网网卡，虚拟机双网卡，实现内外访问。</p>
<h3 id="为PVE虚拟机启用MAC地址欺骗"><a href="#为PVE虚拟机启用MAC地址欺骗" class="headerlink" title="为PVE虚拟机启用MAC地址欺骗"></a>为PVE虚拟机启用MAC地址欺骗</h3><p>选中虚拟机， 进入设置，在网络适配器 》 高级功能里面，勾选 启用mac地址欺骗。</p>
<p>如果不启用的话， pve虚拟机里面创建的虚拟机，不能与windows通信。</p>
]]></content>
      <categories>
        <category>虚拟化技术</category>
        <category>Hyper-V</category>
      </categories>
  </entry>
  <entry>
    <title>WSL2常用命令</title>
    <url>/posts/aa06bf22.html</url>
    <content><![CDATA[<h2 id="WSL常用命令"><a href="#WSL常用命令" class="headerlink" title="WSL常用命令"></a>WSL常用命令</h2><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --help Help 命令</span><br><span class="line">wsl --status  检查 WSL 状态</span><br><span class="line">wsl --update  更新 WSL</span><br><span class="line">wsl --shutdown  关闭</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">wsl -l 或 wsl --list 列出所有已安装虚拟机</span><br><span class="line">wsl -l -v 显示详细信息(也不怎么详细)</span><br><span class="line">wsl -l -o 列出网上可用的系统</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">wsl -t ubuntu 关闭ubuntu</span><br><span class="line">wsl --shutdown 关闭所有系统及虚拟机引擎</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">wsl -d ubuntu 启动ubuntu并进行终端</span><br><span class="line">wsl -u root 以root身份支行</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">wsl --install 安装默认虚拟机(ubuntu)</span><br><span class="line">wsl -l -o 列出网上可用的系统</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">wsl 启动默认虚拟机并进入终端</span><br><span class="line">wsl -s 虚拟机名 进入默认虚拟机</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>虚拟化技术</category>
        <category>WSL2</category>
      </categories>
  </entry>
  <entry>
    <title>ProxmoxVE 安装 Rocky Linux</title>
    <url>/posts/3b09c10b.html</url>
    <content><![CDATA[<h2 id="RHEL-Rocky-Almalinux-Fedora-网络配置"><a href="#RHEL-Rocky-Almalinux-Fedora-网络配置" class="headerlink" title="RHEL&#x2F;Rocky&#x2F;Almalinux&#x2F;Fedora 网络配置"></a>RHEL&#x2F;Rocky&#x2F;Almalinux&#x2F;Fedora 网络配置</h2><h3 id="设置静态IP地址"><a href="#设置静态IP地址" class="headerlink" title="设置静态IP地址"></a>设置静态IP地址</h3><p>基于<code>nmcli</code>命令，一条命令即可完成静态IP配置，重启系统后生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli connection modify \</span><br><span class="line">    <span class="string">&quot;<span class="subst">$(nmcli -t -f NAME c show --active | awk &#x27;! /^lo/ &#123; printf <span class="string">&quot;%s\n&quot;</span>, $0 &#125;&#x27;)</span>&quot;</span> \</span><br><span class="line">    connection.autoconnect <span class="built_in">yes</span> \</span><br><span class="line">    ipv4.method manual \</span><br><span class="line">    ipv4.addresses <span class="string">&quot;172.17.1.116/16&quot;</span> \</span><br><span class="line">    ipv4.gateway 172.17.0.2 \</span><br><span class="line">    ipv4.dns 8.8.8.8,8.8.4.4 \</span><br><span class="line">    ipv6.method disabled</span><br></pre></td></tr></table></figure>


<span id="more"></span>

]]></content>
      <categories>
        <category>虚拟化技术</category>
        <category>ProxmoxVE</category>
      </categories>
  </entry>
  <entry>
    <title>ProxmoxVE 安装 Ubuntu Server</title>
    <url>/posts/d05a23e4.html</url>
    <content><![CDATA[<h2 id="Ubuntu-网络配置"><a href="#Ubuntu-网络配置" class="headerlink" title="Ubuntu 网络配置"></a>Ubuntu 网络配置</h2><p>Ubuntu使用netplan来管理网络，默认使用dhcp，设置静态IP地址需要手写配置文件。</p>
<p>参考官方文档的配置： <a href="https://ubuntu.com/server/docs/network-configuration">点击跳转</a></p>
<span id="more"></span>


<h3 id="设置DHCP"><a href="#设置DHCP" class="headerlink" title="设置DHCP"></a>设置DHCP</h3><p>Ubuntu 的 systemd-networkd 默认使用 &#x2F;etc&#x2F;machine-id 来识别机器，当虚拟机克隆的时候，他们都有一样的 &#x2F;etc&#x2F;machine-id 和 DHCP server，因此返回的都是同一个 ip 了。</p>
<p>手写配置文件，完整配置文件<code>00-installer-config.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">ens33:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 加上这一行，可以避免克隆的虚拟机获取到相同的IP地址</span></span><br><span class="line">      <span class="attr">dhcp-identifier:</span> <span class="string">mac</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="设置静态IP地址"><a href="#设置静态IP地址" class="headerlink" title="设置静态IP地址"></a>设置静态IP地址</h3><p>手写配置文件，完整配置文件<code>00-installer-config.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">ens18:</span></span><br><span class="line">      <span class="attr">link-local:</span> [ <span class="string">ipv4</span> ]  </span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">no</span></span><br><span class="line">      <span class="attr">addresses:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.1</span><span class="number">.121</span><span class="string">/16</span></span><br><span class="line">      <span class="attr">gateway4:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">      <span class="attr">nameservers:</span></span><br><span class="line">          <span class="attr">addresses:</span> [<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, <span class="number">8.8</span><span class="number">.4</span><span class="number">.4</span>]</span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>虚拟化技术</category>
        <category>ProxmoxVE</category>
      </categories>
  </entry>
  <entry>
    <title>ProxmoxVE虚拟机回收磁盘空间</title>
    <url>/posts/cc4b022f.html</url>
    <content><![CDATA[<h2 id="使用trim进行回收"><a href="#使用trim进行回收" class="headerlink" title="使用trim进行回收"></a>使用trim进行回收</h2><h3 id="第一步：设置磁盘选项"><a href="#第一步：设置磁盘选项" class="headerlink" title="第一步：设置磁盘选项"></a>第一步：设置磁盘选项</h3><p>ProxmoxVE创建的Linux虚拟机，可以支持trim，可以很方便的回收磁盘空间。</p>
<p>选择虚拟机的磁盘，在设置里面，勾选ssd仿真和丢弃。</p>
<h3 id="第二步：虚拟机内执行回收命令"><a href="#第二步：虚拟机内执行回收命令" class="headerlink" title="第二步：虚拟机内执行回收命令"></a>第二步：虚拟机内执行回收命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fstrim -av</span><br></pre></td></tr></table></figure>

<p>等待命令执行完成，即可完成磁盘空间回收。</p>
]]></content>
      <categories>
        <category>虚拟化技术</category>
        <category>ProxmoxVE</category>
      </categories>
  </entry>
  <entry>
    <title>ProxmoxVE 安装 Fedora X11 环境</title>
    <url>/posts/b2111cfc.html</url>
    <content><![CDATA[<h2 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h2><p>安装 vcxsrv, xshell, xftp。</p>
<p>clion在Windows上可以远程linux开发，但是调试多个tcp程序不如命令行手动gdb来的实在。<br>调试redis源码也要用gdb，反正无论怎样都是要用gdb调试的，逃不开躲不过，还是尽早适应的好。</p>
<p>不在xshell中用vim写C++，而是通过X11使用vscode写C++。不使用vscode调试C++，而是在命令行手动gdb进行调试。</p>
<span id="more"></span>

<p>vim的配置太恶心了，要什么功能都要用插件去实现，选插件然后配置太麻烦，关键的是没法保证实现想要的效果，浪费生命浪费时间。</p>
<p>抛弃vim，拥抱vscode，从我做起！</p>
<p>在windows上跑虚拟机才是正解，linux开发环境使用X11更加方便，只要CPU够强、内存够大，鱼与熊掌可以兼得。</p>
<h2 id="Fedora34系统环境从零开始"><a href="#Fedora34系统环境从零开始" class="headerlink" title="Fedora34系统环境从零开始"></a>Fedora34系统环境从零开始</h2><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><h4 id="1-使用-Fedora-Workstation-Live-x86-64-34-1-2-iso-安装系统"><a href="#1-使用-Fedora-Workstation-Live-x86-64-34-1-2-iso-安装系统" class="headerlink" title="1. 使用 Fedora-Workstation-Live-x86_64-34-1.2.iso 安装系统"></a>1. 使用 <code>Fedora-Workstation-Live-x86_64-34-1.2.iso</code> 安装系统</h4><p>开发环境使用 Workstation版， 不用Server版。配置默认为字符界面，桌面在需要时再进行切换。</p>
<p>自定义LVM磁盘分区, 设置登录账号。</p>
<h4 id="2-更新系统"><a href="#2-更新系统" class="headerlink" title="2. 更新系统"></a>2. 更新系统</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lukas@fedora muduo]$ dnf update</span><br></pre></td></tr></table></figure>

<h4 id="3-调整运行级别"><a href="#3-调整运行级别" class="headerlink" title="3. 调整运行级别"></a>3. 调整运行级别</h4><p>配置默认为字符界面，这样虚拟机需要的运行资源占用少。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lukas@fedora muduo]$ systemctl set-default runlevel3.target</span><br></pre></td></tr></table></figure>

<h4 id="4-C-编译工具"><a href="#4-C-编译工具" class="headerlink" title="4. C++编译工具"></a>4. C++编译工具</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf install -y boost boost-devel zlib-devel curl-devel \</span><br><span class="line">protobuf protobuf-devel cmake gcc gcc-c++ gdb make \</span><br><span class="line">tmux git vim openssh-server</span><br><span class="line"></span><br><span class="line">dnf install -y clang clang-devel clang-libs llvm llvm-doc \</span><br><span class="line">llvm-devel clang-tools-extra clang-analyzer</span><br></pre></td></tr></table></figure>

<h4 id="5-VSCode"><a href="#5-VSCode" class="headerlink" title="5. VSCode"></a>5. VSCode</h4><p>5.1 按文档安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://code.visualstudio.com/docs/setup/linux</span><br></pre></td></tr></table></figure>

<p>5.2 launch.json 示例</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asio_chat_server&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/bin/asio_chat_server&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;4000&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build-all&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>5.3 tasks.json 示例</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build-all&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/bash vscode.sh&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>菜单 终端 -&gt; 运行生成任务(Ctrl+Shift+B), 会运行 tasks.json 中 <code>&quot;isDefault&quot;: true</code> 的task。</p>
<h2 id="X11环境下的输入法"><a href="#X11环境下的输入法" class="headerlink" title="X11环境下的输入法"></a>X11环境下的输入法</h2><p>Fedora默认输入法是Ibus，当运行级别为3的时候，Ibus相关的服务不是开机启动的，需要你在xshell连上之后，手动启动ibus。</p>
<h3 id="0-用到的包"><a href="#0-用到的包" class="headerlink" title="0. 用到的包"></a>0. 用到的包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[lukas@localhost yum.repos.d]$ rpm -qa | grep ^ibus</span><br><span class="line">ibus-libs-1.5.24-5.fc34.x86_64</span><br><span class="line">ibus-gtk2-1.5.24-5.fc34.x86_64</span><br><span class="line">ibus-gtk3-1.5.24-5.fc34.x86_64</span><br><span class="line">ibus-1.5.24-5.fc34.x86_64</span><br><span class="line">ibus-setup-1.5.24-5.fc34.noarch</span><br><span class="line">ibus-libzhuyin-1.10.0-2.fc34.x86_64</span><br><span class="line">ibus-m17n-1.4.9-1.fc34.x86_64</span><br><span class="line">ibus-libpinyin-1.12.0-3.fc34.x86_64</span><br><span class="line">ibus-anthy-python-1.5.12-7.fc34.noarch</span><br><span class="line">ibus-anthy-1.5.12-7.fc34.x86_64</span><br><span class="line">ibus-hangul-1.5.4-5.fc34.x86_64</span><br><span class="line">ibus-typing-booster-2.15.16-1.fc34.noarch</span><br><span class="line">[lukas@localhost yum.repos.d]$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dnf install ibus-libs ibus-gtk2 ibus-gtk3 ibus ibus-setup ibus-libzhuyin ibus-m17n ibus-libpinyin ibus-anthy-python ibus-anthy ibus-hangul ibus-typing-booster xsel</span><br></pre></td></tr></table></figure>

<h3 id="1-复制粘贴"><a href="#1-复制粘贴" class="headerlink" title="1. 复制粘贴"></a>1. 复制粘贴</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dnf -y install xsel</span><br></pre></td></tr></table></figure>

<h3 id="1-设置快捷键"><a href="#1-设置快捷键" class="headerlink" title="1. 设置快捷键"></a>1. 设置快捷键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[lukas@fedora muduo]$ ibus-setup</span><br></pre></td></tr></table></figure>

<p>在程序窗口中设置为 Ctrl + 空格</p>
<h3 id="2-设置Ibus相关环境变量"><a href="#2-设置Ibus相关环境变量" class="headerlink" title="2. 设置Ibus相关环境变量"></a>2. 设置Ibus相关环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export XIM=ibus</span><br><span class="line">export GTK_IM_MODULE=ibus</span><br><span class="line">export QT_IM_MODULE=ibus</span><br><span class="line">export XIM_PROGRAM=&quot;ibus-daemon&quot;</span><br><span class="line">export XMODIFIERS=&quot;@im=ibus&quot;</span><br></pre></td></tr></table></figure>

<p>在 ~&#x2F;.bashrc 里面添加</p>
<h3 id="3-手动启动Ibus守护进程"><a href="#3-手动启动Ibus守护进程" class="headerlink" title="3. 手动启动Ibus守护进程"></a>3. 手动启动Ibus守护进程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ibus-daemon -x -d</span><br></pre></td></tr></table></figure>


<h3 id="4-剪切板复制粘贴"><a href="#4-剪切板复制粘贴" class="headerlink" title="4. 剪切板复制粘贴"></a>4. 剪切板复制粘贴</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ForwardX11 yes</span><br></pre></td></tr></table></figure>

<p>修改ssh配置，在 <code>/etc/ssh/ssh_config</code> 文件配置上述选项。<br>vmware中启用剪切板复制粘贴。</p>
<h2 id="X11环境下可能出现的问题"><a href="#X11环境下可能出现的问题" class="headerlink" title="X11环境下可能出现的问题"></a>X11环境下可能出现的问题</h2><ol>
<li>文本输入时，按了字母数字外的键盘按键，出现一直输入222222222222222222222222无法停止的现象</li>
</ol>
<p>这是一个偶尔出现的状况，不太清楚原因，没找到彻底的解决办法。</p>
<p>解决办法： 关闭程序，重新开启程序</p>
]]></content>
      <categories>
        <category>虚拟化技术</category>
        <category>ProxmoxVE</category>
      </categories>
  </entry>
  <entry>
    <title>C++语言标准编译器支持情况</title>
    <url>/posts/6c4ebde5.html</url>
    <content><![CDATA[<h2 id="已完全实现的C-标准"><a href="#已完全实现的C-标准" class="headerlink" title="已完全实现的C++标准"></a>已完全实现的C++标准</h2><ul>
<li>到目前为止， 各大编译器已经完全实现所有特性的最新标准是 C++17。 </li>
<li>C++标准委员会虽然已经发布了更加新的标准，比如：C++20， C++23， C++26，这些标准也带来了新特性；</li>
<li>但是编译器的实现没跟上啊， 编译器只实现了部分标准特性，并未完全实现。</li>
</ul>
<h2 id="编译器实现状态跟踪"><a href="#编译器实现状态跟踪" class="headerlink" title="编译器实现状态跟踪"></a>编译器实现状态跟踪</h2><h3 id="1-GCC"><a href="#1-GCC" class="headerlink" title="1. GCC"></a>1. GCC</h3><ul>
<li><a href="https://gcc.gnu.org/projects/cxx-status.html">https://gcc.gnu.org/projects/cxx-status.html</a></li>
</ul>
<h3 id="2-Clang"><a href="#2-Clang" class="headerlink" title="2. Clang"></a>2. Clang</h3><ul>
<li><a href="https://clang.llvm.org/cxx_status.html">https://clang.llvm.org/cxx_status.html</a></li>
</ul>
<h3 id="3-MSVC"><a href="#3-MSVC" class="headerlink" title="3. MSVC"></a>3. MSVC</h3><ul>
<li><a href="https://learn.microsoft.com/en-us/cpp/overview/visual-cpp-language-conformance">https://learn.microsoft.com/en-us/cpp/overview/visual-cpp-language-conformance</a></li>
</ul>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>C++编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>自定义配置HttpClient</title>
    <url>/posts/fe742f1.html</url>
    <content><![CDATA[<h2 id="完全封装-HttpClient"><a href="#完全封装-HttpClient" class="headerlink" title="完全封装 HttpClient"></a>完全封装 HttpClient</h2><ol>
<li>自定义 HttpClientFactory 请求类</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISampleClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetData</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleClient</span> : <span class="title">ISampleClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleClient</span>(<span class="params">HttpClient httpClient</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        httpClient.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">&quot;https://api.SampleClient.com/&quot;</span>);</span><br><span class="line">        httpClient.DefaultRequestHeaders.Add(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        httpClient.DefaultRequestHeaders.Add(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;HttpClientFactory-Sample&quot;</span>);</span><br><span class="line">        _client = httpClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> _client.GetStringAsync(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在Startup.cs中ConfigureService方法中注册SampleClient</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">services.AddHttpClient&lt;ISampleClient, SampleClient&gt;();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>从容器获取实例</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ISampleClient  _sampleClient;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValuesController</span>(<span class="params">ISampleClient  sampleClient</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _sampleClient = sampleClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="keyword">await</span> _sampleClient.GetData();</span><br><span class="line">        <span class="keyword">return</span> Ok(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>.NET开发</category>
        <category>ASP.NET Core</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP请求参数处理</title>
    <url>/posts/141ae08f.html</url>
    <content><![CDATA[<h2 id="HTTP请求参数枚举类型的处理"><a href="#HTTP请求参数枚举类型的处理" class="headerlink" title="HTTP请求参数枚举类型的处理"></a>HTTP请求参数枚举类型的处理</h2><p>业务上使用枚举类型，标识业务某一类的类型，代码上更加可读。</p>
<p>枚举其实是一个int类型的数字，那么在传参的时候，直接使用int类型作为请求参数的类型，后面再转换成业务相关的枚举类型，进行比较等操作。</p>
<h2 id="HTTP请求参数日期时间类型的处理"><a href="#HTTP请求参数日期时间类型的处理" class="headerlink" title="HTTP请求参数日期时间类型的处理"></a>HTTP请求参数日期时间类型的处理</h2><h3 id="前端给后端传参？"><a href="#前端给后端传参？" class="headerlink" title="前端给后端传参？"></a>前端给后端传参？</h3><p>使用时间戳</p>
<p>  这么做</p>
<h3 id="后端给前端返回结果"><a href="#后端给前端返回结果" class="headerlink" title="后端给前端返回结果"></a>后端给前端返回结果</h3><p>  涉及到时区的处理，前端后端要有统一的约定。<br>  例如： 统一使用utc时间，不同时区的时间处理，交给不同时区的web和客户端去具体处理。</p>
]]></content>
      <categories>
        <category>.NET开发</category>
        <category>ASP.NET Core</category>
      </categories>
  </entry>
  <entry>
    <title>指定AspNetCore运行地址的方法</title>
    <url>/posts/b211bc83.html</url>
    <content><![CDATA[<h1 id="How-to-specify-the-port-an-ASP-NET-Core-application-is-hosted-on"><a href="#How-to-specify-the-port-an-ASP-NET-Core-application-is-hosted-on" class="headerlink" title="How to specify the port an ASP.NET Core application is hosted on?"></a>How to specify the port an ASP.NET Core application is hosted on?</h1><p>In ASP.NET Core 3.1, there are 4 main ways to specify a custom port:</p>
<h3 id="Using-command-line-arguments-by-starting-your-NET-application-with-–urls-url"><a href="#Using-command-line-arguments-by-starting-your-NET-application-with-–urls-url" class="headerlink" title="Using command line arguments, by starting your .NET application with –urls&#x3D;[url]:"></a>Using command line arguments, by starting your .NET application with –urls&#x3D;[url]:</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet run <span class="literal">--urls</span>=http://localhost:<span class="number">5001</span>/</span><br></pre></td></tr></table></figure>

<h3 id="Using-appsettings-json-by-adding-a-Urls-node"><a href="#Using-appsettings-json-by-adding-a-Urls-node" class="headerlink" title="Using appsettings.json, by adding a Urls node:"></a>Using appsettings.json, by adding a Urls node:</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Urls&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:5001&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Using-environment-variables-with-ASPNETCORE-URLS-http-localhost-5001"><a href="#Using-environment-variables-with-ASPNETCORE-URLS-http-localhost-5001" class="headerlink" title="Using environment variables, with ASPNETCORE_URLS&#x3D;http://localhost:5001/."></a>Using environment variables, with ASPNETCORE_URLS&#x3D;<a href="http://localhost:5001/">http://localhost:5001/</a>.</h3><h3 id="Using-UseUrls-if-you-prefer-doing-it-programmatically"><a href="#Using-UseUrls-if-you-prefer-doing-it-programmatically" class="headerlink" title="Using UseUrls(), if you prefer doing it programmatically:"></a>Using UseUrls(), if you prefer doing it programmatically:</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span> =&gt;</span><br><span class="line">        CreateHostBuilder(<span class="keyword">args</span>).Build().Run();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span> =&gt;</span><br><span class="line">        Host.CreateDefaultBuilder(<span class="keyword">args</span>)</span><br><span class="line">            .ConfigureWebHostDefaults(builder =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                builder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                builder.UseUrls(<span class="string">&quot;http://localhost:5001/&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Or, if you’re still using the web host builder instead of the generic host builder:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span> =&gt;</span><br><span class="line">        <span class="keyword">new</span> WebHostBuilder()</span><br><span class="line">            .UseKestrel()</span><br><span class="line">            .UseContentRoot(Directory.GetCurrentDirectory())</span><br><span class="line">            .UseIISIntegration()</span><br><span class="line">            .UseStartup&lt;Startup&gt;()</span><br><span class="line">            .UseUrls(<span class="string">&quot;http://localhost:5001/&quot;</span>)</span><br><span class="line">            .Build()</span><br><span class="line">            .Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>.NET开发</category>
        <category>ASP.NET Core</category>
      </categories>
  </entry>
  <entry>
    <title>编译ASP.NET Core源码</title>
    <url>/posts/b063dee6.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>项目编译官方文档：<a href="https://github.com/dotnet/aspnetcore/blob/main/docs/BuildFromSource.md">https://github.com/dotnet/aspnetcore/blob/main/docs/BuildFromSource.md</a></li>
</ul>
<h2 id="第一步：设置代理环境变量"><a href="#第一步：设置代理环境变量" class="headerlink" title="第一步：设置代理环境变量"></a>第一步：设置代理环境变量</h2><p><code>ASP.NET Core</code>项目的编译脚本需要在线下载很多东西， 鉴于国内的网络环境，如果你没有一个快速的代理， 基本上编译脚本是没希望执行成功的。</p>
<p>因此，如果想要快速顺利的编译项目，必须要设置代理。</p>
<h3 id="方式1：-从控制面板里面配置环境变量（一直有效）"><a href="#方式1：-从控制面板里面配置环境变量（一直有效）" class="headerlink" title="方式1： 从控制面板里面配置环境变量（一直有效）"></a>方式1： 从控制面板里面配置环境变量（一直有效）</h3><p>跟平常修改windows path环境变量一样的方法， 在控制面板里面，新建 <code>HTTP_PROXY</code>、<code>HTTPS_PROXY</code> 这两个环境变量。</p>
<h3 id="方式2：-从Powershell命令行手动设置（临时有效）"><a href="#方式2：-从Powershell命令行手动设置（临时有效）" class="headerlink" title="方式2： 从Powershell命令行手动设置（临时有效）"></a>方式2： 从Powershell命令行手动设置（临时有效）</h3><p>Powershell中使用下列命令设置环境变量：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$env:HTTP_PROXY</span>=<span class="string">&quot;http://127.0.0.1:1080&quot;</span></span><br><span class="line"><span class="variable">$env:HTTPS_PROXY</span>=<span class="string">&quot;http://127.0.0.1:1080&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="检查环境变量是否生效"><a href="#检查环境变量是否生效" class="headerlink" title="检查环境变量是否生效"></a>检查环境变量是否生效</h3><p>上面两种方式，选其一设置即可。</p>
<p>打开<code>Powershell</code>，输入 <code>$env:HTTPS_PROXY</code>，<code>$env:HTTPS_PROXY</code> 两条命令，检查输出，看环境变量是否生效。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\&gt; <span class="variable">$env:HTTPS_PROXY</span></span><br><span class="line">http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">1080</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> D:\&gt; <span class="variable">$env:HTTP_PROXY</span></span><br><span class="line">http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">1080</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> D:\&gt; </span><br></pre></td></tr></table></figure>

<h2 id="第二步：下载源码"><a href="#第二步：下载源码" class="headerlink" title="第二步：下载源码"></a>第二步：下载源码</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:</span><br><span class="line">git clone <span class="literal">--recursive</span> https://github.com/dotnet/aspnetcore.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> D:\aspnetcore</span><br><span class="line">git submodule update <span class="literal">--init</span> <span class="literal">--recursive</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于特定版本创建新分支，这样就可以把修改保存在新分支上。</span></span><br><span class="line">git checkout v8.<span class="number">0.5</span></span><br><span class="line">git branch review<span class="literal">-v8</span>.<span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<h2 id="第三步：安装需要的Visual-Studio组件"><a href="#第三步：安装需要的Visual-Studio组件" class="headerlink" title="第三步：安装需要的Visual Studio组件"></a>第三步：安装需要的<code>Visual Studio</code>组件</h2><p>为了编译项目需要安装很多Visual Studio组件，项目开发人员很贴心，仓库里面已经提供了VS2022安装配置文件<code>.vsconfig</code>，导入配置文件进行安装就好了。</p>
<p>即使你已经安装了 <code>Visual Studio 2022</code> ，也要使用 <code>.vsconfig</code> 配置文件重新导入一下，不然在后面的步骤，可能会因为缺失组件而报错。</p>
<p>导入方法： 打开<code>Visual Studio Installer</code>， 更多 -&gt; 载入配置 -&gt; 选择 <code>D:\aspnetcore\.vsconfig</code> -&gt; 查看详细信息。</p>
<ul>
<li>关于<code>Visual Studio</code>导入或导出安装配置的说明，MSDN文档链接如下：</li>
<li><a href="https://learn.microsoft.com/zh-cn/visualstudio/install/import-export-installation-configurations">https://learn.microsoft.com/zh-cn/visualstudio/install/import-export-installation-configurations</a></li>
</ul>
<h2 id="第四步：正式编译步骤"><a href="#第四步：正式编译步骤" class="headerlink" title="第四步：正式编译步骤"></a>第四步：正式编译步骤</h2><p>按照仓库里面提供的文档，你只需要在Powershell里面执行<code>.\restore.cmd</code>即可，这也是提供编译脚本的目的。</p>
<p>但是， 你人在国内，由于网络问题，导致无法正常下载编译需要用到的文件，所以如果没有代理，你不可能顺利执行脚本成功的。</p>
<p>为了能够顺利执行脚本成功，你还需要进行如下额外的步骤。</p>
<h3 id="1-修改编译脚本使用代理加速下载"><a href="#1-修改编译脚本使用代理加速下载" class="headerlink" title="1. 修改编译脚本使用代理加速下载"></a>1. 修改编译脚本使用代理加速下载</h3><h4 id="1-1-修改eng-common-tools-ps1-文件"><a href="#1-1-修改eng-common-tools-ps1-文件" class="headerlink" title="1.1 修改eng\common\tools.ps1 文件"></a>1.1 修改<code>eng\common\tools.ps1</code> 文件</h4><p>搜索文件内所有的 <code>Invoke-WebRequest</code>，脚本使用此命令下载文件，添加<code>-Proxy</code>选项，可以让该命令走代理。</p>
<p>因此我们把<code>Invoke-WebRequest</code>改成 <code>Invoke-WebRequest -Proxy &quot;http://127.0.0.1:1080&quot; </code>。</p>
<p>搜索<code>Attempting to install</code>，找到 <code>$installScript @variation</code> , 这一行的意思是使用微软官方的<code>dotnet-install-script</code>来安装 .net sdk，该脚本提供了<code>-ProxyAddress</code>选项，用于指定代理。</p>
<p>因此我们把<code>$installScript @variation</code>改成<code>$installScript -ProxyAddress &quot;http://127.0.0.1:1080&quot; @variation</code>。</p>
<h4 id="1-2-命令参考文档："><a href="#1-2-命令参考文档：" class="headerlink" title="1.2 命令参考文档："></a>1.2 命令参考文档：</h4><ul>
<li><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-webrequest">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-webrequest</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script">https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script</a></li>
</ul>
<h3 id="2-使用nvm管理Node-js的版本"><a href="#2-使用nvm管理Node-js的版本" class="headerlink" title="2. 使用nvm管理Node.js的版本"></a>2. 使用nvm管理Node.js的版本</h3><p>ASP.NET Core项目源码依赖特定版本的<code>Node.js</code>，通常不会是最新版本的<code>Node.js</code>。 </p>
<p>如果你现有安装的<code>Node.js</code>版本匹配不上项目依赖，项目编译就会报错，这就需要<code>Node.js</code>多版本并存安装，这里推荐使用<code>nvm</code>来管理多版本的<code>Node.js</code>。</p>
<ul>
<li><code>nvm</code>项目地址：<a href="https://github.com/coreybutler/nvm-windows">https://github.com/coreybutler/nvm-windows</a></li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装并使用 Node.js 18.20.2</span></span><br><span class="line">nvm install <span class="number">18.20</span>.<span class="number">2</span></span><br><span class="line">nvm use <span class="number">18.20</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装并使用 Node.js 19.8.1</span></span><br><span class="line">nvm install <span class="number">19.8</span>.<span class="number">1</span></span><br><span class="line">nvm use <span class="number">19.8</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当然，你也可以手动下载 Node.js 安装包进行安装， 只要跟项目依赖能匹配上就行。</li>
<li>对于 ASP.NET Core v8.0.5 源码，使用 18.x 或 19.x 都是可以的，二选一安装即可。</li>
<li>对于 ASP.NET Core 其他版本的源码，根据报错信息，安装相应版本即可。</li>
</ul>
<h3 id="3-还原项目"><a href="#3-还原项目" class="headerlink" title="3. 还原项目"></a>3. 还原项目</h3><p>经过上面的操作，我们已经安装好了所有需要的 <code>Visual Studio</code> 组件，设置了代理，安装了项目匹配的 <code>Node.js</code> 版本。</p>
<p>现在可以执行<code>.\restore.cmd</code> 了， 这个时候执行脚本还原项目就不会出错了。</p>
<h2 id="第五步：Visual-Studio打开项目"><a href="#第五步：Visual-Studio打开项目" class="headerlink" title="第五步：Visual Studio打开项目"></a>第五步：Visual Studio打开项目</h2><p>使用 <code>startvs.cmd</code> 调用 Visual Studio 2022 来打开项目， 不要直接双击sln文件。</p>
<h3 id="为什么不能直接双击sln文件？"><a href="#为什么不能直接双击sln文件？" class="headerlink" title="为什么不能直接双击sln文件？"></a>为什么不能直接双击sln文件？</h3><ul>
<li>脚本下载安装的编译工具都在 <code>D:\aspnetcore\.dotnet</code>，<code>D:\aspnetcore\.tools</code> 目录，这些文件夹都在Git仓库目录下面，这些路径非SDK默认路径，是需要进行配置的。</li>
<li>你需要使用脚本来加载项目的相关配置，如果不使用<code>startvs.cmd</code>，会缺失配置。</li>
</ul>
]]></content>
      <categories>
        <category>.NET开发</category>
        <category>ASP.NET Core</category>
      </categories>
  </entry>
  <entry>
    <title>未编辑文章</title>
    <url>/posts/68b6e80b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
  </entry>
  <entry>
    <title>编译.NET Runtime源码</title>
    <url>/posts/8c23d09a.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>项目编译官方文档：<a href="https://github.com/dotnet/runtime/blob/main/docs/workflow/README.md">https://github.com/dotnet/runtime/blob/main/docs/workflow/README.md</a></li>
</ul>
<h2 id="第一步：设置代理环境变量"><a href="#第一步：设置代理环境变量" class="headerlink" title="第一步：设置代理环境变量"></a>第一步：设置代理环境变量</h2><p><code>.NET Runtime</code>项目的编译脚本需要在线下载很多东西， 鉴于国内的网络环境，如果你没有一个快速的代理， 基本上编译脚本是没希望执行成功的。</p>
<p>因此，如果想要快速顺利的编译项目，必须要设置代理。</p>
<h3 id="方式1：-从控制面板里面配置环境变量（一直有效）"><a href="#方式1：-从控制面板里面配置环境变量（一直有效）" class="headerlink" title="方式1： 从控制面板里面配置环境变量（一直有效）"></a>方式1： 从控制面板里面配置环境变量（一直有效）</h3><p>跟平常修改windows path环境变量一样的方法， 在控制面板里面，新建 <code>HTTP_PROXY</code>、<code>HTTPS_PROXY</code> 这两个环境变量。</p>
<h3 id="方式2：-从Powershell命令行手动设置（临时有效）"><a href="#方式2：-从Powershell命令行手动设置（临时有效）" class="headerlink" title="方式2： 从Powershell命令行手动设置（临时有效）"></a>方式2： 从Powershell命令行手动设置（临时有效）</h3><p>Powershell中使用下列命令设置环境变量：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$env:HTTP_PROXY</span>=<span class="string">&quot;http://127.0.0.1:1080&quot;</span></span><br><span class="line"><span class="variable">$env:HTTPS_PROXY</span>=<span class="string">&quot;http://127.0.0.1:1080&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="检查环境变量是否生效"><a href="#检查环境变量是否生效" class="headerlink" title="检查环境变量是否生效"></a>检查环境变量是否生效</h3><p>上面两种方式，选其一设置即可。</p>
<p>打开<code>Powershell</code>，输入 <code>$env:HTTPS_PROXY</code>，<code>$env:HTTPS_PROXY</code> 两条命令，检查输出，看环境变量是否生效。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\&gt; <span class="variable">$env:HTTPS_PROXY</span></span><br><span class="line">http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">1080</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> D:\&gt; <span class="variable">$env:HTTP_PROXY</span></span><br><span class="line">http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">1080</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> D:\&gt; </span><br></pre></td></tr></table></figure>

<h2 id="第二步：-下载源码"><a href="#第二步：-下载源码" class="headerlink" title="第二步： 下载源码"></a>第二步： 下载源码</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:</span><br><span class="line">git clone <span class="literal">--recursive</span> https://github.com/dotnet/runtime.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> D:\runtime</span><br><span class="line">git submodule update <span class="literal">--init</span> <span class="literal">--recursive</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于特定版本创建新分支，这样就可以把修改保存在新分支上。</span></span><br><span class="line">git checkout v8.<span class="number">0.5</span></span><br><span class="line">git branch review<span class="literal">-v8</span>.<span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<h2 id="第三步：-安装需要的Visual-Studio组件"><a href="#第三步：-安装需要的Visual-Studio组件" class="headerlink" title="第三步： 安装需要的Visual Studio组件"></a>第三步： 安装需要的<code>Visual Studio</code>组件</h2><p>为了编译项目需要安装很多Visual Studio组件，项目开发人员很贴心，仓库里面已经提供了VS2022安装配置文件<code>.vsconfig</code>，导入配置文件进行安装就好了。</p>
<p>即使你已经安装了 <code>Visual Studio 2022</code> ，也要使用 <code>.vsconfig</code> 配置文件重新导入一下，不然在后面的步骤，可能会因为缺失组件而报错。</p>
<p>导入方法： 打开<code>Visual Studio Installer</code>， 更多 -&gt; 载入配置 -&gt; 选择 <code>.vsconfig</code> -&gt; 查看详细信息。</p>
<ul>
<li>关于<code>Visual Studio</code>导入或导出安装配置的说明，MSDN文档链接如下：</li>
<li><a href="https://learn.microsoft.com/zh-cn/visualstudio/install/import-export-installation-configurations">https://learn.microsoft.com/zh-cn/visualstudio/install/import-export-installation-configurations</a></li>
</ul>
<h2 id="第三步：正式编译步骤"><a href="#第三步：正式编译步骤" class="headerlink" title="第三步：正式编译步骤"></a>第三步：正式编译步骤</h2><h3 id="1-编译项目"><a href="#1-编译项目" class="headerlink" title="1. 编译项目"></a>1. 编译项目</h3><p>在.NET Runtime项目文件夹，执行下列命令，进行编译。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置代理</span></span><br><span class="line"><span class="variable">$env:HTTP_PROXY</span>=<span class="string">&quot;http://127.0.0.1:1080&quot;</span></span><br><span class="line"><span class="variable">$env:HTTPS_PROXY</span>=<span class="string">&quot;http://127.0.0.1:1080&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译项目</span></span><br><span class="line">.\build.cmd clr+libs <span class="literal">-rc</span> Release</span><br></pre></td></tr></table></figure>

<ul>
<li>注意： 一定要设置代理, 这个很重要；</li>
</ul>
<h3 id="2-在vs中打开项目"><a href="#2-在vs中打开项目" class="headerlink" title="2. 在vs中打开项目"></a>2. 在vs中打开项目</h3><p>如果你要查看的项目，项目文件夹内有sln文件，你可以直接使用<code>visual studio</code>打开。</p>
<p>如果项目文件夹内没有sln文件，从命令行执行下列命令，该命令会自动调用<code>visual studio</code>并打开项目。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># System.Private.CoreLib 是项目文件夹的名称， 换成你要查看的项目。</span></span><br><span class="line"></span><br><span class="line">.\build.cmd <span class="literal">-vs</span> System.Private.CoreLib</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>.NET开发</category>
        <category>.NET Runtime</category>
      </categories>
      <tags>
        <tag>.NET Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>未编辑文章</title>
    <url>/posts/68b6e80b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
  </entry>
  <entry>
    <title>ArrayList初始化</title>
    <url>/posts/b2f6d048.html</url>
    <content><![CDATA[<p>1、使用Arrays.asList（）方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>2、使用生成匿名内部内进行初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; initList2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(initList2);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用addAll方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; obj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">obj.addAll(list);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>


<p>4、常规方式(最为常用的)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list3.add(<span class="number">1</span>);</span><br><span class="line">list3.add(<span class="number">5</span>);</span><br><span class="line">System.out.println(list3);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java开发</category>
        <category>Java编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>未编辑文章</title>
    <url>/posts/68b6e80b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
  </entry>
  <entry>
    <title>未编辑文章</title>
    <url>/posts/68b6e80b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
  </entry>
  <entry>
    <title>未编辑文章</title>
    <url>/posts/68b6e80b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
  </entry>
  <entry>
    <title>使用nvm管理Node.js的版本</title>
    <url>/posts/db3ec352.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>项目管理之中，经常要用到不同版本的<code>Node.js</code>，比如：不同版本的Electron项目依赖不同版本的<code>Node.js</code>。 这时候我们需要多版本并存， 同时安装多个版本，然后借助工具进行切换当前使用的版本。 <code>nvm</code> 这个工具很好的实现了这个需求， 推荐使用。</p>
<h2 id="Windows下使用nvm"><a href="#Windows下使用nvm" class="headerlink" title="Windows下使用nvm"></a>Windows下使用<code>nvm</code></h2><ul>
<li><a href="https://github.com/coreybutler/nvm-windows">https://github.com/coreybutler/nvm-windows</a></li>
</ul>
<p>从<code>release</code>页面下载最新的安装包，使用安装包进行安装，完成之后即可在终端里面使用 <code>nvm</code> 命令。 后续如果要升级<code>nvm</code>版本， 重新下载安装即可，非常方便。</p>
<h2 id="Linux与MacOS下使用nvm"><a href="#Linux与MacOS下使用nvm" class="headerlink" title="Linux与MacOS下使用nvm"></a>Linux与MacOS下使用<code>nvm</code></h2><ul>
<li><a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></li>
</ul>
<p>支持多种安装方法， 按照说明进行安装即可。 这里演示在Linux的bash下，使用克隆Git仓库的方式进行安装。</p>
<h3 id="1-克隆源码仓库，并切换至最新版本"><a href="#1-克隆源码仓库，并切换至最新版本" class="headerlink" title="1. 克隆源码仓库，并切换至最新版本"></a>1. 克隆源码仓库，并切换至最新版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/nvm-sh/nvm.git <span class="variable">$HOME</span>/.nvm</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/.nvm</span><br><span class="line">latest_tag=$(git describe --abbrev=0 --tags)</span><br><span class="line">git checkout <span class="string">&quot;<span class="variable">$latest_tag</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-在-bashrc文件中添加以下配置"><a href="#2-在-bashrc文件中添加以下配置" class="headerlink" title="2. 在.bashrc文件中添加以下配置"></a>2. 在<code>.bashrc</code>文件中添加以下配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span>  <span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure>

<h3 id="3-经过前两步操作之后，-每次打开终端都能使用nvm命令。"><a href="#3-经过前两步操作之后，-每次打开终端都能使用nvm命令。" class="headerlink" title="3. 经过前两步操作之后， 每次打开终端都能使用nvm命令。"></a>3. 经过前两步操作之后， 每次打开终端都能使用<code>nvm</code>命令。</h3><h4 id="安装最新的LTS版本"><a href="#安装最新的LTS版本" class="headerlink" title="安装最新的LTS版本"></a>安装最新的LTS版本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm install --lts</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>EF Core设置Gin索引</title>
    <url>/posts/f9f8cb99.html</url>
    <content><![CDATA[<h2 id="EF-Core中如何设置Gin索引"><a href="#EF-Core中如何设置Gin索引" class="headerlink" title="EF Core中如何设置Gin索引?"></a>EF Core中如何设置Gin索引?</h2><p><a href="https://stackoverflow.com/questions/54618858/can-jsonb-gin-indexes-be-specified-in-codefirst-entityframework-with-npgsql">https://stackoverflow.com/questions/54618858/can-jsonb-gin-indexes-be-specified-in-codefirst-entityframework-with-npgsql</a></p>
<hr>
<p>Since .ForNpgsqlHasMethod(“gin”) is obsolete, with EF Core 3.1 you can use this:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">metaBuilder</span><br><span class="line">    .HasIndex(x =&gt; x.DocumentNumber)</span><br><span class="line">    .HasMethod(<span class="string">&quot;gin&quot;</span>)</span><br><span class="line">    .HasOperators(<span class="string">&quot;gin_trgm_ops&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>and your migration will look like this:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">migrationBuilder.CreateIndex(</span><br><span class="line">    name: <span class="string">&quot;IX_DocumentContentMeta_DocumentNumber&quot;</span>,</span><br><span class="line">    table: <span class="string">&quot;DocumentContentMeta&quot;</span>,</span><br><span class="line">    column: <span class="string">&quot;DocumentNumber&quot;</span>)</span><br><span class="line">    .Annotation(<span class="string">&quot;Npgsql:IndexMethod&quot;</span>, <span class="string">&quot;gin&quot;</span>)</span><br><span class="line">    .Annotation(<span class="string">&quot;Npgsql:IndexOperators&quot;</span>, <span class="keyword">new</span>[] &#123; <span class="string">&quot;gin_trgm_ops&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>



<hr>
<p>Well, actually u can do it like this</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Artist&gt;()</span><br><span class="line">       .HasIndex(a =&gt; <span class="keyword">new</span> &#123; a.Album &#125;)</span><br><span class="line">       .ForNpgsqlHasMethod(<span class="string">&quot;gin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and when u run ef add migration, the sql query generated will be like:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX ix_artist_album ON artist USING gin (&quot;album&quot;);</span><br></pre></td></tr></table></figure>

<p>Documentation in Npgsql: <a href="http://www.npgsql.org/efcore/modeling/indexes.html">http://www.npgsql.org/efcore/modeling/indexes.html</a></p>
]]></content>
      <categories>
        <category>关系数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>EFCore</tag>
        <tag>Gin索引</tag>
      </tags>
  </entry>
  <entry>
    <title>PG生成RowNumber行号</title>
    <url>/posts/c110348b.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Oracle ROWNUM是一个虚拟列，每输出一行递增1。  </p>
<h2 id="Oracle-rownum"><a href="#Oracle-rownum" class="headerlink" title="Oracle rownum"></a>Oracle rownum</h2><p>通常被用于LIMIT输出记录数。  </p>
<pre><code>SELECT ROWNUM, empno, ename, job FROM emp WHERE ROWNUM &lt; 5 ORDER BY ename;  
   
 rownum | empno | ename |   job  
--------+-------+-------+----------  
      2 |  7499 | ALLEN | SALESMAN  
      4 |  7566 | JONES | MANAGER  
      1 |  7369 | SMITH | CLERK  
      3 |  7521 | WARD  | SALESMAN  
(4 rows)  
</code></pre>
<p>或者用于生成序列值。  </p>
<pre><code>ALTER TABLE jobhist ADD seqno NUMBER(3);  
UPDATE jobhist SET seqno = ROWNUM;  
</code></pre>
<pre><code>SELECT seqno, empno, TO_CHAR(startdate,&#39;DD-MON-YY&#39;) AS start, job FROM jobhist;  
   
 seqno | empno |   start   |    job  
-------+-------+-----------+-----------  
     1 |  7369 | 17-DEC-80 | CLERK  
     2 |  7499 | 20-FEB-81 | SALESMAN  
     3 |  7521 | 22-FEB-81 | SALESMAN  
     4 |  7566 | 02-APR-81 | MANAGER  
     5 |  7654 | 28-SEP-81 | SALESMAN  
     6 |  7698 | 01-MAY-81 | MANAGER  
     7 |  7782 | 09-JUN-81 | MANAGER  
     8 |  7788 | 19-APR-87 | CLERK  
     9 |  7788 | 13-APR-88 | CLERK  
    10 |  7788 | 05-MAY-90 | ANALYST  
    11 |  7839 | 17-NOV-81 | PRESIDENT  
    12 |  7844 | 08-SEP-81 | SALESMAN  
    13 |  7876 | 23-MAY-87 | CLERK  
    14 |  7900 | 03-DEC-81 | CLERK  
    15 |  7900 | 15-JAN-83 | CLERK  
    16 |  7902 | 03-DEC-81 | ANALYST  
    17 |  7934 | 23-JAN-82 | CLERK  
(17 rows)  
</code></pre>
<h2 id="PostgreSQL-rownum"><a href="#PostgreSQL-rownum" class="headerlink" title="PostgreSQL rownum"></a>PostgreSQL rownum</h2><p>PostgreSQL 目前没有rownum虚拟列，但是实现同样的功能确很容易：  </p>
<p>1、输出行号，使用临时序列  </p>
<pre><code>postgres=# create temp sequence if not exists tmp_seq;  
  
postgres=# alter sequence tmp_seq restart with 1;  
  
postgres=# select nextval(&#39;tmp_seq&#39;) as rownum, * from test limit 10;  
 rownum | id | info |          crt_time            
--------+----+------+----------------------------  
      1 |  1 | test | 2018-01-24 11:06:24.882708  
      2 |  2 | test | 2018-01-24 11:06:24.882708  
      3 |  3 | test | 2018-01-24 11:06:24.882708  
      4 |  4 | test | 2018-01-24 11:06:24.882708  
      5 |  5 | test | 2018-01-24 11:06:24.882708  
      6 |  6 | test | 2018-01-24 11:06:24.882708  
      7 |  7 | test | 2018-01-24 11:06:24.882708  
      8 |  8 | test | 2018-01-24 11:06:24.882708  
      9 |  9 | test | 2018-01-24 11:06:24.882708  
     10 | 10 | test | 2018-01-24 11:06:24.882708  
(10 rows)  
</code></pre>
<p>2、输出行号，使用窗口函数  </p>
<pre><code>postgres=# select row_number() over () as rownum, * from test limit 10;  
 rownum | id | info |          crt_time            
--------+----+------+----------------------------  
      1 |  1 | test | 2018-01-24 11:06:24.882708  
      2 |  2 | test | 2018-01-24 11:06:24.882708  
      3 |  3 | test | 2018-01-24 11:06:24.882708  
      4 |  4 | test | 2018-01-24 11:06:24.882708  
      5 |  5 | test | 2018-01-24 11:06:24.882708  
      6 |  6 | test | 2018-01-24 11:06:24.882708  
      7 |  7 | test | 2018-01-24 11:06:24.882708  
      8 |  8 | test | 2018-01-24 11:06:24.882708  
      9 |  9 | test | 2018-01-24 11:06:24.882708  
     10 | 10 | test | 2018-01-24 11:06:24.882708  
(10 rows)  
</code></pre>
<p>3、LIMIT，直接语法支持  </p>
<pre><code>postgres=# select * from test limit 10;  
 id | info |          crt_time            
----+------+----------------------------  
  1 | test | 2018-01-24 11:06:24.882708  
  2 | test | 2018-01-24 11:06:24.882708  
  3 | test | 2018-01-24 11:06:24.882708  
  4 | test | 2018-01-24 11:06:24.882708  
  5 | test | 2018-01-24 11:06:24.882708  
  6 | test | 2018-01-24 11:06:24.882708  
  7 | test | 2018-01-24 11:06:24.882708  
  8 | test | 2018-01-24 11:06:24.882708  
  9 | test | 2018-01-24 11:06:24.882708  
 10 | test | 2018-01-24 11:06:24.882708  
(10 rows)  
</code></pre>
<p>4、为某个字段生成序列值。  </p>
<pre><code>postgres=# create temp sequence if not exists tmp_seq;  
  
postgres=# alter sequence tmp_seq restart with 1;  
  
postgres=# alter table test add column col1 int;  
ALTER TABLE  
  
postgres=# update test set col1=nextval(&#39;tmp_seq&#39;);  
UPDATE 10000000  
  
postgres=# select * from test limit 10;  
 id | info |          crt_time          | col1   
----+------+----------------------------+------  
  1 | test | 2018-01-24 11:06:24.882708 |    1  
  2 | test | 2018-01-24 11:06:24.882708 |    2  
  3 | test | 2018-01-24 11:06:24.882708 |    3  
  4 | test | 2018-01-24 11:06:24.882708 |    4  
  5 | test | 2018-01-24 11:06:24.882708 |    5  
  6 | test | 2018-01-24 11:06:24.882708 |    6  
  7 | test | 2018-01-24 11:06:24.882708 |    7  
  8 | test | 2018-01-24 11:06:24.882708 |    8  
  9 | test | 2018-01-24 11:06:24.882708 |    9  
 10 | test | 2018-01-24 11:06:24.882708 |   10  
(10 rows)  
</code></pre>
]]></content>
      <categories>
        <category>关系数据库</category>
        <category>PostgreSQL</category>
      </categories>
  </entry>
  <entry>
    <title>PostgreSQL时间戳</title>
    <url>/posts/fdd22a85.html</url>
    <content><![CDATA[<h2 id="DataGrip设置时区"><a href="#DataGrip设置时区" class="headerlink" title="DataGrip设置时区"></a>DataGrip设置时区</h2><p>DataGrip时区默认是 UTC+0, 不是UTC+8, 在连接属性里面设置UTC+8。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li>右键打开你想要修改的数据库连接的Properties菜单；</li>
<li>点击Advanced按钮；</li>
<li>在VM options后面写入-Duser.timezone&#x3D;Asia&#x2F;Shanghai，就可以啦；</li>
<li>断开数据库连接，重新执行一条SQL就可以看到效果了。</li>
</ol>
<h2 id="PG中时间戳类型的查询写法"><a href="#PG中时间戳类型的查询写法" class="headerlink" title="PG中时间戳类型的查询写法"></a>PG中时间戳类型的查询写法</h2><h3 id="时间戳存储"><a href="#时间戳存储" class="headerlink" title="时间戳存储"></a>时间戳存储</h3><p>对于timestamp with time zone，内部存储的值总是 UTC （全球统一时间，以前也叫格林威治时间GMT）。<br>如果一个输入值有明确的时区声明， 那么它将用该时区合适的偏移量转换成 UTC。<br>如果在输入串里没有时区声明， 那么它就被假设是在系统的TimeZone参数里的那个时区，然后使用这个 timezone时区的偏移转换成 UTC。 </p>
<h3 id="双冒号语法"><a href="#双冒号语法" class="headerlink" title="双冒号语法"></a>双冒号语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 操作符  ==&gt; PostgreSQL风格的类型转换</span><br></pre></td></tr></table></figure>

<p>在PostgreSQL数据库中，双冒号:: 是用于类型转换的，比如’2010-01-01’::date。</p>
<h3 id="时间戳查询"><a href="#时间戳查询" class="headerlink" title="时间戳查询"></a>时间戳查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TIMEZONE <span class="keyword">TO</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">current_timestamp</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;2021-12-18 19:53:49.985033+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;2021-12-18 19:53:49+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;Order&quot; <span class="keyword">where</span> &quot;CreationTime&quot; <span class="operator">=</span> <span class="string">&#x27;2021-12-19 15:49:31.210972+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;Order&quot;</span><br><span class="line"><span class="keyword">where</span> &quot;PaymentTime&quot;  </span><br><span class="line"><span class="keyword">between</span> <span class="string">&#x27;2021-12-19 15:13:10.024023+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone</span><br><span class="line"><span class="keyword">and</span> <span class="string">&#x27;2021-12-19 16:45:15.108045+08&#x27;</span>::<span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="程序中时间戳类型的选择"><a href="#程序中时间戳类型的选择" class="headerlink" title="程序中时间戳类型的选择"></a>程序中时间戳类型的选择</h2><h3 id="C-类型DateTime和DateTimeOffset的选择"><a href="#C-类型DateTime和DateTimeOffset的选择" class="headerlink" title="C#类型DateTime和DateTimeOffset的选择"></a>C#类型DateTime和DateTimeOffset的选择</h3><p>在程序中统一使用UTC时间，http请求参数使用DateTimeOffset；<br>在参数解析绑定时，DateTimeOffset类型会自动带上本地时区的Offset，<br>而 DateTime 不会有时区信息，Kind属性值是DateTimeKind.Unspecified，</p>
<p>前端给后端传时间戳，后端收到转成utc时间(使用DateTimeOffset类型)，这样可以避免处理时区的问题。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;date1&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;JsonResult&gt; <span class="title">DatetimeOffset1</span>(<span class="params">DateTime dt</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// http://localhost:9000/api/date1?dt=2021-12-19 15:13:10</span></span><br><span class="line">    <span class="comment">// &quot;2021-12-19T15:13:10&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> Task.FromResult(<span class="keyword">new</span> JsonResult(dt));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;date2&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;JsonResult&gt; <span class="title">DatetimeOffset2</span>(<span class="params">DateTimeOffset dt</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// http://localhost:9000/api/date2?dt=2021-12-19 15:13:10</span></span><br><span class="line">    <span class="comment">// &quot;2021-12-19T15:13:10+08:00&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> Task.FromResult(<span class="keyword">new</span> JsonResult(dt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JsonResult中DateTimeOffset的格式化"><a href="#JsonResult中DateTimeOffset的格式化" class="headerlink" title="JsonResult中DateTimeOffset的格式化"></a>JsonResult中DateTimeOffset的格式化</h3><ol>
<li>编写自定义转换器</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Globalization;</span><br><span class="line"><span class="keyword">using</span> System.Text.Json;</span><br><span class="line"><span class="keyword">using</span> System.Text.Json.Serialization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Practical.Api.Helper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DateTimeOffsetConverter</span> : <span class="title">JsonConverter</span>&lt;<span class="title">DateTimeOffset</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DateTimeOffset <span class="title">Read</span>(<span class="params"><span class="keyword">ref</span> Utf8JsonReader reader, </span></span></span><br><span class="line"><span class="params"><span class="function">            Type typeToConvert, </span></span></span><br><span class="line"><span class="params"><span class="function">            JsonSerializerOptions options</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> DateTimeOffset</span><br><span class="line">            .ParseExact(reader.GetString(), <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>, CultureInfo.InvariantCulture);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Write</span>(<span class="params">Utf8JsonWriter writer, </span></span></span><br><span class="line"><span class="params"><span class="function">            DateTimeOffset <span class="keyword">value</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">            JsonSerializerOptions options</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            writer.WriteStringValue(<span class="keyword">value</span>.ToLocalTime()</span><br><span class="line">                .ToString(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>, CultureInfo.InvariantCulture));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>StartUp类中配置序列化选项</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    services.AddControllers()</span><br><span class="line">    .AddJsonOptions(op =&gt; op.JsonSerializerOptions</span><br><span class="line">                            .Converters.Add(<span class="keyword">new</span> DateTimeOffsetConverter()));</span><br><span class="line">    services.AddSwaggerGen(c =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        c.SwaggerDoc(<span class="string">&quot;v1&quot;</span>, <span class="keyword">new</span> OpenApiInfo &#123; Title = <span class="string">&quot;Practical.API&quot;</span>, Version = <span class="string">&quot;v1&quot;</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    RegisterMediatR(services);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Newtonsoft.Json库使用JsonSerializerSettings进行设置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var settings = new JsonSerializerSettings()</span><br><span class="line">&#123;</span><br><span class="line">    DateFormatString = &quot;yyyy-MM-dd HH:mm:ss&quot;,</span><br><span class="line">    DateTimeZoneHandling = DateTimeZoneHandling.Local</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>参考文章：<br><a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-converters-how-to?pivots=dotnet-6-0#sample-basic-converter">https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-converters-how-to?pivots=dotnet-6-0#sample-basic-converter</a></p>
<h3 id="JS时间戳的转换"><a href="#JS时间戳的转换" class="headerlink" title="JS时间戳的转换"></a>JS时间戳的转换</h3><p>首先要清楚JavaScript与Unix的时间戳的区别：</p>
<p>JavaScript时间戳：是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总毫秒数。</p>
<p>Unix时间戳：是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</p>
<p>可以看出JavaScript时间戳总毫秒数，Unix时间戳是总秒数。</p>
<p>比如同样是的 2016&#x2F;11&#x2F;03 12:30:00 ，转换为JavaScript时间戳为 1478147400000；转换为Unix时间戳为 1478147400。</p>
<ol>
<li>C# DateTime转换为JavaScript时间戳</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 当地时区</span></span><br><span class="line">System.DateTime startTime = TimeZone.CurrentTimeZone</span><br><span class="line">                                    .ToLocalTime(<span class="keyword">new</span> System.DateTime(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">long</span> timeStamp = (<span class="built_in">long</span>)(DateTime.Now - startTime).TotalMilliseconds; <span class="comment">// 相差毫秒数</span></span><br><span class="line">System.Console.WriteLine(timeStamp);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>JavaScript时间戳转换为C# DateTime</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">long</span> jsTimeStamp = <span class="number">1478169023479</span>;</span><br><span class="line"> <span class="comment">// 当地时区</span></span><br><span class="line">System.DateTime startTime = TimeZone.CurrentTimeZone</span><br><span class="line">                                    .ToLocalTime(<span class="keyword">new</span> System.DateTime(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">DateTime dt = startTime.AddMilliseconds(jsTimeStamp);</span><br><span class="line">System.Console.WriteLine(dt.ToString(<span class="string">&quot;yyyy/MM/dd HH:mm:ss:ffff&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> udt1 = DateTimeOffset.FromUnixTimeSeconds(<span class="number">1478147400</span>);</span><br><span class="line"><span class="keyword">var</span> udt2 = DateTimeOffset.FromUnixTimeMilliseconds(<span class="number">1478147400000</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>JavaScript获取时间戳与时间戳转化</li>
</ol>
<p>Javascript 获取当前时间戳（毫秒级别）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">第一种方法：结果：<span class="number">1470220594000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timestamp1 = <span class="title class_">Date</span>.<span class="title function_">parse</span>( <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二种方法：结果：<span class="number">1470220608533</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timestamp2 = ( <span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">valueOf</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三种方法：结果：<span class="number">1470220608533</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timestamp3 = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br></pre></td></tr></table></figure>

<p>第一种获取的时间戳是精确到秒。<br>第二种和第三种是获取的时间戳精确到毫秒。</p>
<h2 id="获取时间戳的方法还有：-new-Date-Date-now-这个ES5才添加的方法还有-new-Date-0"><a href="#获取时间戳的方法还有：-new-Date-Date-now-这个ES5才添加的方法还有-new-Date-0" class="headerlink" title="获取时间戳的方法还有：+new Date();Date.now(); &#x2F;&#x2F; 这个ES5才添加的方法还有 new Date - 0;"></a>获取时间戳的方法还有：<br>+new Date();<br>Date.now(); &#x2F;&#x2F; 这个ES5才添加的方法<br>还有 new Date - 0;</h2><p>获取指定时间的时间戳：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2016-08-03 00:00:00&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>时间戳转化成时间：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timetrans</span>(<span class="params">date</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(date*<span class="number">1000</span>);<span class="comment">//如果date为13位不需要乘1000</span></span><br><span class="line">    <span class="keyword">var</span> Y = date.<span class="title function_">getFullYear</span>() + <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> M = (date.<span class="title function_">getMonth</span>()+<span class="number">1</span> &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span>+(date.<span class="title function_">getMonth</span>()+<span class="number">1</span>) : date.<span class="title function_">getMonth</span>()+<span class="number">1</span>) + <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> D = (date.<span class="title function_">getDate</span>() &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + (date.<span class="title function_">getDate</span>()) : date.<span class="title function_">getDate</span>()) + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> h = (date.<span class="title function_">getHours</span>() &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + date.<span class="title function_">getHours</span>() : date.<span class="title function_">getHours</span>()) + <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> m = (date.<span class="title function_">getMinutes</span>() &lt;<span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + date.<span class="title function_">getMinutes</span>() : date.<span class="title function_">getMinutes</span>()) + <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> s = (date.<span class="title function_">getSeconds</span>() &lt;<span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + date.<span class="title function_">getSeconds</span>() : date.<span class="title function_">getSeconds</span>());</span><br><span class="line">    <span class="keyword">return</span> Y+M+D+h+m+s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>关系数据库</category>
        <category>PostgreSQL</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<h2 id="树的考察知识点"><a href="#树的考察知识点" class="headerlink" title="树的考察知识点"></a>树的考察知识点</h2><p>主要分为：</p>
<ul>
<li>1、树相关</li>
<li>2、二叉树相关</li>
</ul>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>1、树的实现（链式存储-链表，线性存储-数组）<br>2、树的遍历（前序遍历，中序变量，后序遍历）（DFS遍历、BFS遍历）<br>3、树的转换 （链式存储 &lt;–&gt; 线性存储 两者之间相互转换）<br>4、最近公共祖先简称 LCA（Lowest Common Ancestor）<br>5、<br>6、Trie树（字典树）</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>1、二叉树的实现<br>2、二叉树的遍历<br>3、二叉搜索树（Binary Search Tree, BST） （常用操作：查找、插入、删除节点）<br>4、平衡的二叉搜索树（AVL树、红黑树、伸展树、替罪羊树）<br>5、特殊概念的二叉树（满二叉树、完全二叉树、）</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<h2 id="图的考察知识点"><a href="#图的考察知识点" class="headerlink" title="图的考察知识点"></a>图的考察知识点</h2><p>概念： 无向图、有向图、有向无环图。 关注图的连通性、图的边是否有权。环又称为回路。</p>
<p>1、最小生成树<br>2、最短路径（单源最短路径SSSP -&gt; 一对顶点，多源最短路径MSSP -&gt; 所有顶点对）<br>3、强连通分量<br>4、图的表示实现（邻接表）<br>5、拓扑排序（针对有向无环图进行的排序）（如果图有回路，则拓扑排序是不可能的）<br>6、找环（无向图找环、有向图找环）</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>无权最短路径 –&gt; 加权图（Dijkstra算法） –&gt; 具有负边值的图 （结合无权与加权算法进行解决）</p>
<p>无环图 –&gt;  关键路径分析</p>
<p>找出所有顶点对之间的最短路径？（多源最短路径MSSP）</p>
<h3 id="网络流问题"><a href="#网络流问题" class="headerlink" title="网络流问题"></a>网络流问题</h3>]]></content>
  </entry>
  <entry>
    <title>Git常用命令总结</title>
    <url>/posts/3b0bf668.html</url>
    <content><![CDATA[<h2 id="Git分支合并"><a href="#Git分支合并" class="headerlink" title="Git分支合并"></a>Git分支合并</h2><h3 id="分支合并之前怎么检测是否有冲突？"><a href="#分支合并之前怎么检测是否有冲突？" class="headerlink" title="分支合并之前怎么检测是否有冲突？"></a>分支合并之前怎么检测是否有冲突？</h3><p>场景举例：</p>
<ol>
<li><p>个人分支：personal</p>
</li>
<li><p>项目主干分支：master</p>
</li>
<li><p>开发人员在个人分支上进行特性开发，期间可能会往远端库推送多次，最终会合入到主干分支</p>
</li>
</ol>
<p>怎么检测？</p>
<p>通过三路合并检测：</p>
<ol>
<li><p>通过<code>git merge-base personal master</code>找出共同的节点，称之为：base_sha</p>
</li>
<li><p>通过<code>git merge-tree base_sha personal master</code>获取合并后的结果</p>
</li>
<li><p>如果输出有<code>changed in both</code>字样，那说明存在冲突</p>
</li>
</ol>
<p>总结</p>
<ol>
<li><p>定期拉取主干分支，更新到个人分支，保持与主干分支差异最想</p>
</li>
<li><p>开发完成后，尽快合入 </p>
</li>
<li><p>根据冲突提前检测，统计出频繁冲突文件列表，能够提前预警</p>
</li>
</ol>
<h3 id="怎么进行git-rebase合并分支？"><a href="#怎么进行git-rebase合并分支？" class="headerlink" title="怎么进行git rebase合并分支？"></a>怎么进行<code>git rebase</code>合并分支？</h3><h2 id="Git日志"><a href="#Git日志" class="headerlink" title="Git日志"></a>Git日志</h2><h3 id="怎么查看最近三次的提交信息？"><a href="#怎么查看最近三次的提交信息？" class="headerlink" title="怎么查看最近三次的提交信息？"></a>怎么查看最近三次的提交信息？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -3</span><br></pre></td></tr></table></figure>

<h3 id="git-走代理"><a href="#git-走代理" class="headerlink" title="git:// 走代理"></a><code>git://</code> 走代理</h3><p>~&#x2F;.ssh&#x2F;config 文件权限 600</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[lukas@localhost pygyme]$ cat ~/.ssh/config</span><br><span class="line">Host github.com *.github.com</span><br><span class="line">    User git</span><br><span class="line">    Hostname %h</span><br><span class="line">    ProxyCommand nc -x 172.17.0.1:7890 %h %p</span><br><span class="line">[lukas@localhost pygyme]$</span><br><span class="line">[lukas@localhost yum.repos.d]$ ls -l ~/.ssh/config</span><br><span class="line">-rw------- 1 lukas lukas 74  3月 10 21:41 /home/lukas/.ssh/config</span><br><span class="line">[lukas@localhost yum.repos.d]$</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发经验总结</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git的cherry-pick挑选提交</title>
    <url>/posts/edd14fab.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>开发经验总结</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git的merge合并</title>
    <url>/posts/251f8e94.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>开发经验总结</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git的rebase合并</title>
    <url>/posts/3fb04da2.html</url>
    <content><![CDATA[<h1 id="使用Git的rebase合并"><a href="#使用Git的rebase合并" class="headerlink" title="使用Git的rebase合并"></a>使用Git的rebase合并</h1><h2 id="使用-Git-rebase-合并多次提交，避免无意义提交，保持-Git-log-干净且明确"><a href="#使用-Git-rebase-合并多次提交，避免无意义提交，保持-Git-log-干净且明确" class="headerlink" title="使用 Git rebase 合并多次提交，避免无意义提交，保持 Git log 干净且明确"></a>使用 Git rebase 合并多次提交，避免无意义提交，保持 Git log 干净且明确</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 少数几次提交时，把当前分支最新的3个提交合并成一个提交</span></span><br><span class="line"><span class="comment"># vim编辑时，3个提交里面，pick 第一个， squash 其他两个</span></span><br><span class="line">git rebase -i <span class="built_in">head</span>~3      </span><br><span class="line"></span><br><span class="line"><span class="comment"># 非常多次提交时，把位于指定commit id 后面的提交，合并成一个提交； </span></span><br><span class="line"><span class="comment"># 合并的多个commit里面，并不包含指定commit id的那次提交。</span></span><br><span class="line"><span class="comment"># vim编辑时，多个提交里面，pick 第一个， squash 其他提交</span></span><br><span class="line">git rebase -i ed7908d580d877740b37f1d824495852e7ee60af</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发经验总结</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git的log日志</title>
    <url>/posts/e044d4d3.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>开发经验总结</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git的submodule子模块</title>
    <url>/posts/52a1e367.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>开发经验总结</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git的分支</title>
    <url>/posts/4896fdb8.html</url>
    <content><![CDATA[<p>Git Switch 切换分支</p>
]]></content>
      <categories>
        <category>开发经验总结</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git的合并冲突解决</title>
    <url>/posts/12a1f11d.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>开发经验总结</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git的标签</title>
    <url>/posts/e2f94bc9.html</url>
    <content><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>发布新版本， 打个新的tag</li>
<li>在打包失败时自动删除tag</li>
</ul>
<h3 id="查找标签"><a href="#查找标签" class="headerlink" title="查找标签"></a>查找标签</h3><h4 id="1-用于查找最近的tag"><a href="#1-用于查找最近的tag" class="headerlink" title="1.用于查找最近的tag"></a>1.用于查找最近的tag</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git describe</span><br></pre></td></tr></table></figure>

<h4 id="2-把–abbrev设为0-该命令查找最近的tag名，不需要后缀"><a href="#2-把–abbrev设为0-该命令查找最近的tag名，不需要后缀" class="headerlink" title="2. 把–abbrev设为0, 该命令查找最近的tag名，不需要后缀:"></a>2. 把–abbrev设为0, 该命令查找最近的tag名，不需要后缀:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git describe --abbrev=0</span><br></pre></td></tr></table></figure>

<h4 id="3-获取当前分支的tag"><a href="#3-获取当前分支的tag" class="headerlink" title="3. 获取当前分支的tag"></a>3. 获取当前分支的tag</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git describe --abbrev=0 --tags </span><br></pre></td></tr></table></figure>

<h4 id="4-获取所有分支的tag"><a href="#4-获取所有分支的tag" class="headerlink" title="4. 获取所有分支的tag"></a>4. 获取所有分支的tag</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git describe --tags `git rev-list --tags --max-count=1`</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发经验总结</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>设置Git使用代理</title>
    <url>/posts/7082d8ce.html</url>
    <content><![CDATA[<h2 id="HTTP协议代理"><a href="#HTTP协议代理" class="headerlink" title="HTTP协议代理"></a>HTTP协议代理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:5080</span><br><span class="line">git config --global https.proxy http://127.0.0.1:5080</span><br></pre></td></tr></table></figure>


<h2 id="SSH协议代理"><a href="#SSH协议代理" class="headerlink" title="SSH协议代理"></a>SSH协议代理</h2><h3 id="Windows下面配置"><a href="#Windows下面配置" class="headerlink" title="Windows下面配置"></a>Windows下面配置</h3><p>在 <code>.ssh</code> 目录下，新建 <code>C:\Users\lukas\.ssh\config</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 走HTTP代理</span><br><span class="line"># proxyCommand &quot;C:\Program Files\Git\mingw64\bin\connect&quot; -H 127.0.0.1:5080 %h %p</span><br><span class="line"></span><br><span class="line"># 走Socks代理</span><br><span class="line">proxyCommand &quot;C:\Program Files\Git\mingw64\bin\connect&quot; -S 127.0.0.1:5081 %h %p</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 22</span><br><span class="line">  Hostname github.com</span><br><span class="line">  </span><br><span class="line">Host ssh.github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 443</span><br><span class="line">  Hostname ssh.github.com</span><br></pre></td></tr></table></figure>

<ul>
<li>注意是 <code>C:\Users\lukas\.ssh\config</code> 文件, 而不是 <code>C:\Users\lukas\.gitconfig</code> 文件, 不要搞混了。</li>
<li><code>connect</code> 命令，只要安装了 <code>Git for windows</code> 就会有， 记得找到正确的位置。</li>
<li><code>127.0.0.1:5081</code> 是 socket5 服务器地址</li>
<li>不用写 <code>IdentityFile</code> 指令， 执行git命令时，会自动读取相关私钥文件；只要配置了相应的私钥，就不会有问题。</li>
</ul>
<h3 id="Linux系统下配置"><a href="#Linux系统下配置" class="headerlink" title="Linux系统下配置"></a>Linux系统下配置</h3><h4 id="1-安装转发工具"><a href="#1-安装转发工具" class="headerlink" title="1. 安装转发工具"></a>1. 安装转发工具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/os-release</span><br><span class="line">case $ID in</span><br><span class="line">debian|ubuntu)</span><br><span class="line">    apt-get install -y ncat psmisc</span><br><span class="line">    ;;</span><br><span class="line">rhel|rocky|almalinux|fedora)</span><br><span class="line">    dnf install -y nmap-ncat</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    echo &quot;当前系统不受支持, Shell脚本退出执行!&quot;</span><br><span class="line">    exit 1</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h4 id="2-ssh-config文件添加下列内容"><a href="#2-ssh-config文件添加下列内容" class="headerlink" title="2. .ssh/config文件添加下列内容"></a>2. <code>.ssh/config</code>文件添加下列内容</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProxyCommand /usr/bin/ncat --proxy 127.0.0.1:5080 --proxy-type http %h %p</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 22</span><br><span class="line">  Hostname github.com</span><br><span class="line">  </span><br><span class="line">Host ssh.github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 443</span><br><span class="line">  Hostname ssh.github.com</span><br></pre></td></tr></table></figure>


<h3 id="Mac系统配置"><a href="#Mac系统配置" class="headerlink" title="Mac系统配置"></a>Mac系统配置</h3><h4 id="1-安装转发工具-1"><a href="#1-安装转发工具-1" class="headerlink" title="1. 安装转发工具"></a>1. 安装转发工具</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install socat</span><br></pre></td></tr></table></figure>

<h4 id="2-ssh-config文件添加下列内容-1"><a href="#2-ssh-config文件添加下列内容-1" class="headerlink" title="2. .ssh/config文件添加下列内容"></a>2. <code>.ssh/config</code>文件添加下列内容</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=8080</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 22</span><br><span class="line">  Hostname github.com</span><br><span class="line">  </span><br><span class="line">Host ssh.github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 443</span><br><span class="line">  Hostname ssh.github.com</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发经验总结</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>设置Git跨平台换行符</title>
    <url>/posts/1144ab7.html</url>
    <content><![CDATA[<h2 id="设置Git跨平台换行符"><a href="#设置Git跨平台换行符" class="headerlink" title="设置Git跨平台换行符"></a>设置Git跨平台换行符</h2><h3 id="core-autocrlf-配置选项"><a href="#core-autocrlf-配置选项" class="headerlink" title="core.autocrlf 配置选项"></a><code>core.autocrlf</code> 配置选项</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交时转换为LF，检出时转换为CRLF</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时转换为LF，检出时不转换</span></span><br><span class="line">git config --global core.autocrlf input</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交检出均不转换</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="core-safecrlf-配置选项"><a href="#core-safecrlf-配置选项" class="headerlink" title="core.safecrlf 配置选项"></a><code>core.safecrlf</code> 配置选项</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拒绝提交包含混合换行符的文件</span></span><br><span class="line">git config --global core.safecrlf <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许提交包含混合换行符的文件</span></span><br><span class="line">git config --global core.safecrlf <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交包含混合换行符的文件时给出警告</span></span><br><span class="line">git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure>

<h3 id="换行符实际问题"><a href="#换行符实际问题" class="headerlink" title="换行符实际问题"></a>换行符实际问题</h3><p>Git跨平台工作时，才会碰到下面的问题， 如果一直在单一平台下工作，应该不会碰见该问题。</p>
<ol>
<li>问题描述</li>
</ol>
<ul>
<li>Windows 默认换行符 CRLF</li>
<li>Linux   默认换行符 LF</li>
<li>Mac     默认换行符 LF</li>
</ul>
<p>对于Git仓库中的文件，文件内如果出现非本平台的换行符，文件被视为整个被修改，从而导致出现下面这种情况：</p>
<ul>
<li>对于已经提交的文件， 由于换行符导致的问题， 被Git显示为未提交</li>
</ul>
<ol start="2">
<li>问题解决方案</li>
</ol>
<p>Git跨平台下换行符使用原则： </p>
<ul>
<li>Git提交时统一使用 LF</li>
<li>Git检出时， 根据自己的平台来决定是否转换为CRLF</li>
<li>不要提交CRLF到仓库，提交时应该统一使用LF</li>
</ul>
<p>对于windows平台，推荐Git进行以下设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">true</span></span><br><span class="line">git config --global core.safecrlf <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这样配置的意思是：</p>
<ul>
<li>提交时自动转换为LF，检出时转换为CRLF</li>
<li>拒绝提交包含混合换行符的文件</li>
</ul>
<p>对于Linux&#x2F;MAC平台，推荐Git进行以下设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br><span class="line">git config --global core.safecrlf <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这样配置的意思是：</p>
<ul>
<li>提交时自动转换为LF，检出时不转换为CRLF</li>
<li>拒绝提交包含混合换行符的文件</li>
</ul>
<ol start="3">
<li>为什么要 拒绝提交包含混合换行符的文件 ？</li>
</ol>
<p>因为混合换行符会影响到 Git 的 diff 功能， 导致明明文件内容没有修改，却因为换行符，Git会显示文件被修改，从而影响到我们查看diff。</p>
]]></content>
      <categories>
        <category>开发经验总结</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的数据结构（4）：字典</title>
    <url>/posts/a674f514.html</url>
    <content><![CDATA[<ul>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E5%89%8D%E8%A8%80">Redis源码分析：前言</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%881%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2">Redis的数据结构（1）：字符串</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8">Redis的数据结构（2）：链表</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88">Redis的数据结构（3）：整数集合</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89%EF%BC%9A%E5%AD%97%E5%85%B8">Redis的数据结构（4）：字典</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%881%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8">Redis的网络IO（1）：事件驱动</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%882%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">Redis的网络IO（2）：事件循环</a></li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的数据结构（1）：字符串</title>
    <url>/posts/36d3ed6d.html</url>
    <content><![CDATA[<ul>
<li><a href="/202308/redis-source-code-analysis">Redis源码分析：前言</a></li>
<li><a href="/202308/redis-data-structures-string">Redis的数据结构（1）：字符串</a></li>
<li><a href="/202308/redis-data-structures-linked-list">Redis的数据结构（2）：链表</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88">Redis的数据结构（3）：整数集合</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89%EF%BC%9A%E5%AD%97%E5%85%B8">Redis的数据结构（4）：字典</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%881%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8">Redis的网络IO（1）：事件驱动</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%882%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">Redis的网络IO（2）：事件循环</a></li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的数据结构（3）：整数集合</title>
    <url>/posts/8fe7064d.html</url>
    <content><![CDATA[<ul>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E5%89%8D%E8%A8%80">Redis源码分析：前言</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%881%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2">Redis的数据结构（1）：字符串</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8">Redis的数据结构（2）：链表</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88">Redis的数据结构（3）：整数集合</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89%EF%BC%9A%E5%AD%97%E5%85%B8">Redis的数据结构（4）：字典</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%881%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8">Redis的网络IO（1）：事件驱动</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%882%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">Redis的网络IO（2）：事件循环</a></li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的数据结构（2）：链表</title>
    <url>/posts/56ff6e70.html</url>
    <content><![CDATA[<ul>
<li><a href="/redis-source-code-analysis">Redis源码分析：前言</a></li>
<li><a href="/redis-data-structures-string">Redis的数据结构（1）：字符串</a></li>
<li><a href="/redis-data-structures-linked-list.html">Redis的数据结构（2）：链表</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88">Redis的数据结构（3）：整数集合</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89%EF%BC%9A%E5%AD%97%E5%85%B8">Redis的数据结构（4）：字典</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%881%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8">Redis的网络IO（1）：事件驱动</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%882%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">Redis的网络IO（2）：事件循环</a></li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的网络IO（2）：事件循环</title>
    <url>/posts/8202d557.html</url>
    <content><![CDATA[<ul>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E5%89%8D%E8%A8%80">Redis源码分析：前言</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%881%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2">Redis的数据结构（1）：字符串</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8">Redis的数据结构（2）：链表</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88">Redis的数据结构（3）：整数集合</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89%EF%BC%9A%E5%AD%97%E5%85%B8">Redis的数据结构（4）：字典</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%881%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8">Redis的网络IO（1）：事件驱动</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%882%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">Redis的网络IO（2）：事件循环</a></li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码分析：前言</title>
    <url>/posts/dcfe4dc2.html</url>
    <content><![CDATA[<ul>
<li><a href="/redis-source-code-analysis">Redis源码分析：前言</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%881%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2">Redis的数据结构（1）：字符串</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8">Redis的数据结构（2）：链表</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88">Redis的数据结构（3）：整数集合</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89%EF%BC%9A%E5%AD%97%E5%85%B8">Redis的数据结构（4）：字典</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%881%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8">Redis的网络IO（1）：事件驱动</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%882%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">Redis的网络IO（2）：事件循环</a></li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的网络IO（1）：事件驱动</title>
    <url>/posts/fac28c40.html</url>
    <content><![CDATA[<ul>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E5%89%8D%E8%A8%80">Redis源码分析：前言</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%881%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2">Redis的数据结构（1）：字符串</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8">Redis的数据结构（2）：链表</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88">Redis的数据结构（3）：整数集合</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89%EF%BC%9A%E5%AD%97%E5%85%B8">Redis的数据结构（4）：字典</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%881%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8">Redis的网络IO（1）：事件驱动</a></li>
<li><a href="/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Redis%E7%9A%84%E7%BD%91%E7%BB%9CIO%EF%BC%882%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">Redis的网络IO（2）：事件循环</a></li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>free 命令</title>
    <url>/posts/47956.html</url>
    <content><![CDATA[<h1 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h1><p><code>free</code>命令可以显示<code>Linux</code>系统中空闲的、已用的物理内存及<code>swap</code>内存,及被内核使用的<code>buffer</code>。</p>
<h2 id="命令语法说明"><a href="#命令语法说明" class="headerlink" title="命令语法说明"></a>命令语法说明</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 命令格式</span><br><span class="line">free [参数]</span><br><span class="line"># 可选参数</span><br><span class="line">-b 　以Byte为单位显示内存使用情况。 </span><br><span class="line">-k 　以KB为单位显示内存使用情况。 </span><br><span class="line">-m 　以MB为单位显示内存使用情况。</span><br><span class="line">-g   以GB为单位显示内存使用情况。</span><br><span class="line">-h   根据内存大小自动选择合适的单位显示</span><br><span class="line">-o 　不显示缓冲区调节列。 </span><br><span class="line">-s&lt;间隔秒数&gt; 　持续观察内存使用状况。</span><br><span class="line">-c&lt;显示次数&gt;   和-s配合使用</span><br><span class="line">-t 　显示内存总和列。 </span><br><span class="line">-V 　显示版本信息。</span><br></pre></td></tr></table></figure>


<h2 id="输出参数说明"><a href="#输出参数说明" class="headerlink" title="输出参数说明"></a>输出参数说明</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示所有的内存信息，每隔两秒显示一次，一共显示两次</span></span><br><span class="line">[root@slave03 ~]# free -h -s 2 -c 2</span><br><span class="line"></span><br><span class="line">             total       used       free     shared    buffers     cached  available</span><br><span class="line">Mem:          6.6G       5.5G       1.0G       1.1M       247M       3.5G         0B</span><br><span class="line">-/+ buffers/cache:       1.8G       4.8G </span><br><span class="line">Swap:         5.0G       106M       4.9G </span><br></pre></td></tr></table></figure>


<p>先对上面红框中的数据做下说明。Men表示具体的物理内存，free从多个维度统计了物理内存的情况，每个维度的含义如下：</p>
<ul>
<li>total：总计物理内存的大小。</li>
<li>used：已使用的物理内存的大小。</li>
<li>free：可用物理内存有多少。</li>
<li>shared：多个进程共享的内存总额。</li>
<li>buffers：写入磁盘内存缓冲区的大小（经常进行磁盘IO的效率比较低，所以先将要写入磁盘的文件进行一定数量的缓冲，等缓冲数据到达一定大小是一次性写进磁盘，提升效率）</li>
<li>cached：从磁盘中读取内容的缓存大小（原理差不多）。</li>
<li>available：下面会介绍。</li>
<li>-buffers&#x2F;cache：表示被程序实实在在吃掉的内存，比如上图中used内存是5.5G，但是真正被应用程序使用的内存才1.8G，其他被占据的内存主要用来cache数据了，也就是上面的3.5G。</li>
<li>+buffers&#x2F;cache：表示应用程序还可以可以申请的内存总数。</li>
</ul>
<h3 id="free参数和available参数的区别"><a href="#free参数和available参数的区别" class="headerlink" title="free参数和available参数的区别"></a>free参数和available参数的区别</h3><p>在 free 命令的输出中，有一个 free 列，同时还有一个 available 列。这二者到底有何区别？</p>
<p>free 是真正尚未被使用的物理内存数量。至于 available 就比较有意思了，它是从应用程序的角度看到的可用内存数量。</p>
<p>Linux  内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache。所以对于内核来说，buffer 和  cache 都属于已经被使用的内存。</p>
<p>当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache  中回收内存来满足应用程序的请求。从应用程序的角度来说，<strong>available  &#x3D; free + buffer + cache</strong>。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差。</p>
<p>但是上面的available参数为什么输出是0呢？请看官方文档的说明</p>
<blockquote>
<p>The -a switch shows the available memory (if supported by the running kernel and enabled with sysctl -w vm.meminfo_legacy_layout&#x3D;0 ; shows  zero when unsupported or disabled). The produced output is wider than 80 characters.</p>
</blockquote>
<p>这个参数的输出需要操作系统内核支持，如果内核不支持的话就固定输出一个0。</p>
]]></content>
      <categories>
        <category>Linux命令</category>
        <category>内存管理</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统内存占用分析</title>
    <url>/posts/7b067625.html</url>
    <content><![CDATA[<h2 id="使用-free-命令进行分析"><a href="#使用-free-命令进行分析" class="headerlink" title="使用 free 命令进行分析"></a>使用 free 命令进行分析</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-control-plane-02 ~]# free -lwh</span><br><span class="line">              total        used        free      shared     buffers       cache   available</span><br><span class="line">Mem:          7.5Gi       4.7Gi       1.4Gi        72Mi          0B       1.4Gi       2.4Gi</span><br><span class="line">Low:          7.5Gi       6.1Gi       1.4Gi</span><br><span class="line">High:            0B          0B          0B</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">[root@k8s-control-plane-02 ~]#</span><br></pre></td></tr></table></figure>

<ul>
<li>Total(7.5Gi) &#x3D;  Low used(6.1Gi)   + free(1.4Gi)</li>
<li>Low used(6.1Gi) &#x3D; Mem used(4.7Gi) + cache(1.4Gi)</li>
</ul>
<span id="more"></span>

<h3 id="1-cache-字段说明"><a href="#1-cache-字段说明" class="headerlink" title="1. cache 字段说明"></a>1. cache 字段说明</h3><ul>
<li>cache: IO读缓存， 这个IO不只是文件IO，也可以是网络IO</li>
</ul>
<p>cache 就是缓存的意思。当系统读文件的时候，都是把数据从硬盘读到内存里，因为硬盘比内存慢很多，所以这个过程会很耗时。</p>
<p>为了提高效率，linux 会把读进来的文件在内存中缓存下来（因为读取相近部分的内容是程序很常见的情况），即使程序结束，cache 也不会被自动释放。</p>
<p>所以呢，如果有程序进行大量的读文件操作，你会发现内存使用率就上去了。</p>
<p>如果其他程序使用要使用内存的时候，linux 也会把这些没人使用的 cache 释放掉，给其他运行的程序使用。</p>
<p>手动去释放掉这部分内存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

<h3 id="2-buffer-字段说明"><a href="#2-buffer-字段说明" class="headerlink" title="2. buffer 字段说明"></a>2. buffer 字段说明</h3><ul>
<li>buffer: IO写缓存， 这个IO不只是文件IO，也可以是网络IO</li>
</ul>
<p>buffer 的意思和 cache 相近，不过稍有区别。</p>
<p>考虑内存写文件到硬盘的过程，因为硬盘太慢了，如果内存要等待数据写完之后才继续后面的操作，实在是效率很低的事情，也会影响程序的运行速度。</p>
<p>所以就有了 buffer，写到硬盘的数据会放到 buffer 里面，内存很快把数据写到 buffer，可以继续其他的工作，而硬盘可以在后台慢慢读出 buffer 中的数据，保存起来。这样就提高了读写的效率！</p>
<p>讲一个大家会经常遇到的例子，当我们把电脑里中的文件拷贝到 U 盘的时候，如果文件特别大，大家会遇到这种情况：明明看到文件已经拷贝完了，但系统还是会提示 U 盘正在使用中。这就是 buffer 的原因，拷贝程序把东西放到 buffer 之后，但是 U 盘还没有写完。</p>
<p>同样的，可以手动来 flush buffer 的内容，使用的命令是 sync。</p>
<h3 id="3-free-字段说明"><a href="#3-free-字段说明" class="headerlink" title="3. free 字段说明"></a>3. free 字段说明</h3><p>free 是真正尚未被使用的物理内存数量。</p>
<h3 id="4-available-字段说明"><a href="#4-available-字段说明" class="headerlink" title="4. available 字段说明"></a>4. available 字段说明</h3><p>available 是从应用程序的角度看到的可用内存数量。</p>
<p>Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache。所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。</p>
<p>当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。</p>
<p>所以从应用程序的角度来说，available  &#x3D; free + buffer + cache。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差。</p>
<h3 id="5-shared-字段说明"><a href="#5-shared-字段说明" class="headerlink" title="5. shared 字段说明"></a>5. shared 字段说明</h3><p>shared 被共享使用的物理内存大小，是进程间通信的一种方式。</p>
<h3 id="6-swap-字段说明"><a href="#6-swap-字段说明" class="headerlink" title="6. swap 字段说明"></a>6. swap 字段说明</h3><p>swap 是实现虚拟内存的重要概念。如果系统的负载太大，内存被用完，可能会出现严重的问题。</p>
<p>swap 就是把硬盘上一部分空间当做内存使用，正在运行程序会使用物理内存，把没有正在使用的内存放到硬盘，这叫做 swap out；而把硬盘 swap 部分的内存重新放到物理内存中，叫做 swap in。</p>
<p>swap 可以再逻辑上扩大内存空间，但是会造成系统变慢，因为硬盘读写速度很慢。linux 系统比较智能，会把那些不怎么频繁使用的内存放到 swap。</p>
<h3 id="7-proc-meminfo-文件"><a href="#7-proc-meminfo-文件" class="headerlink" title="7. &#x2F;proc&#x2F;meminfo 文件"></a>7. &#x2F;proc&#x2F;meminfo 文件</h3><p>其实 free 命令中的信息都来自于 &#x2F;proc&#x2F;meminfo 文件。&#x2F;proc&#x2F;meminfo 文件包含了更多更原始的信息，只是看起来不太直观：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure>


<h2 id="查看内存占用较高的进程"><a href="#查看内存占用较高的进程" class="headerlink" title="查看内存占用较高的进程"></a>查看内存占用较高的进程</h2><h3 id="使用-top-命令"><a href="#使用-top-命令" class="headerlink" title="使用 top 命令"></a>使用 top 命令</h3><p>执行 top 命令之后， </p>
<ul>
<li>输入 大写P 是按 cpu利用率排序</li>
<li>输入 大写M 是按 内存占用率排序</li>
</ul>
]]></content>
      <categories>
        <category>Linux命令</category>
        <category>内存管理</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux定时任务 corn表达式</title>
    <url>/posts/25166.html</url>
    <content><![CDATA[<h2 id="cron表达式产生的背景"><a href="#cron表达式产生的背景" class="headerlink" title="cron表达式产生的背景"></a>cron表达式产生的背景</h2><p>cron表达式最初是由Unix操作系统中的cron守护进程所使用的一种语法规则，用于设置定时任务。cron守护进程是Unix系统中的一个后台进程，用于周期性地执行指定的命令或脚本。它可以根据用户的需求，按照指定的时间间隔或时间点来执行任务，通常用于定时备份、清理日志、发送邮件等操作。</p>
<p>为了方便用户设置定时任务，cron守护进程引入了一种简单的语法规则，即cron表达式。cron表达式由6个字段组成，分别表示秒、分、小时、日期、月份和星期几。通过这种语法规则，用户可以非常灵活地设置定时任务，满足不同的需求。</p>
<p>随着Unix操作系统的普及和互联网的发展，cron表达式逐渐成为了一种通用的定时任务设置语法，被广泛应用于各种计算机系统和应用程序中。目前，cron表达式已经成为了计算机科学中的一个基本概念，被包括Java、Python、Ruby等编程语言在内的许多软件框架和库所支持和应用。</p>
<h2 id="cron表达式的语法格式"><a href="#cron表达式的语法格式" class="headerlink" title="cron表达式的语法格式"></a>cron表达式的语法格式</h2><p>CRON 表达式是一个字符串，以 5 或 6 个空格隔开，分为 6 或 7 个域，每一个域代表一个含义。 每个域都可以设置一个数字、一组数字（用逗号分隔）、一段数字范围（用短横线分隔）、通配符（表示任意值）或者特定的字符（如星期几的英文缩写）。</p>
<p>CRON 有如下两种语法格式：</p>
<ul>
<li><p>秒 分钟 小时 日期 月份 星期 年</p>
</li>
<li><p>秒 分钟 小时 日期 月份 星期</p>
</li>
</ul>
<h3 id="每个域允许的值"><a href="#每个域允许的值" class="headerlink" title="每个域允许的值"></a>每个域允许的值</h3><table>
<thead>
<tr>
<th>域</th>
<th>允许的数值</th>
<th>允许的特殊字符</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>秒</td>
<td>0~59</td>
<td>- * &#x2F;</td>
<td>无</td>
</tr>
<tr>
<td>分钟</td>
<td>0~59</td>
<td>- * &#x2F;</td>
<td>无</td>
</tr>
<tr>
<td>小时</td>
<td>0~23</td>
<td>- * &#x2F;</td>
<td>无</td>
</tr>
<tr>
<td>日期</td>
<td>1~31</td>
<td>- * ? &#x2F; L W C</td>
<td>无</td>
</tr>
<tr>
<td>月份</td>
<td>1~12</td>
<td>JAN-DEC - * &#x2F;</td>
<td>无</td>
</tr>
<tr>
<td>星期</td>
<td>1~7</td>
<td>SUN-SAT - * ? &#x2F; L C #</td>
<td>1 表示星期天，2 表示星期一，依次类推</td>
</tr>
<tr>
<td>年（可选）</td>
<td>留空，1970~2099</td>
<td>, - * &#x2F;</td>
<td>自动生成，工具不显示该值</td>
</tr>
</tbody></table>
<h3 id="特殊字符的含义"><a href="#特殊字符的含义" class="headerlink" title="特殊字符的含义"></a>特殊字符的含义</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>表示匹配域的任意值</td>
<td>在分这个域使用 <code>*</code>，即表示每分钟都会触发事件。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>表示匹配域的任意值，但只能用在日期和星期两个域，因为这两个域会相互影响。</td>
<td>无</td>
</tr>
<tr>
<td><code>-</code></td>
<td>表示起止范围</td>
<td>在分这个域使用 5-20，表示从 5 分到 20 分钟每分钟触发一次。</td>
</tr>
<tr>
<td><code>/</code></td>
<td>表示起始时间开始触发，然后每隔固定时间触发一次</td>
<td>在分这个域使用 5&#x2F;20，表示在第 5 分钟触发一次，之后每 20 分钟触发一次，即 5、 25、45 等分别触发一次。</td>
</tr>
<tr>
<td><code>,</code></td>
<td>表示列出枚举值</td>
<td>在分这个域使用 5,20，则意味着在 5 和 20 分每分钟触发一次。</td>
</tr>
<tr>
<td><code>L</code></td>
<td>表示匹配域的任意值，但只能用在日期和星期两个域，因为这两个域会相互影响。</td>
<td>无</td>
</tr>
<tr>
<td><code>W</code></td>
<td>表示有效工作日（周一到周五），只能出现在日这个域，系统将在离指定日期最近的有效工作日触发事件。</td>
<td>无</td>
</tr>
<tr>
<td><code>LW</code></td>
<td>这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。</td>
<td>无</td>
</tr>
<tr>
<td><code>#</code></td>
<td>表示每个月第几个星期几，只能出现在星期这个域</td>
<td>在星期这个域使用 4#2，表示某月的第二个星期三，4 表示星期三，2 表示第二个。</td>
</tr>
</tbody></table>
<h3 id="cron表达式示例"><a href="#cron表达式示例" class="headerlink" title="cron表达式示例"></a>cron表达式示例</h3><ul>
<li>*&#x2F;5 * * * * ?：每隔 5 秒执行一次</li>
<li>0 *&#x2F;1 * * * ?：每隔 1 分钟执行一次</li>
<li>0 0 2 1 * ?：每月 1 日的凌晨 2 点执行一次</li>
<li>0 15 10 ? * MON-FRI：周一到周五每天上午 10：15 执行作业</li>
<li>0 15 10 ? 6L 2002-2006：2002 年至 2006 年的每个月的最后一个星期五上午 10:15 执行作业</li>
<li>0 0 23 * * ?：每天 23 点执行一次</li>
<li>0 0 1 * * ?：每天凌晨 1 点执行一次</li>
<li>0 0 1 1 * ?：每月 1 日凌晨 1 点执行一次</li>
<li>0 0 23 L * ?：每月最后一天 23 点执行一次</li>
<li>0 0 1 ? * L：每周星期天凌晨 1 点执行一次</li>
<li>0 26,29,33 * * * ?：在 26 分、29 分、33 分执行一次</li>
<li>0 0 0,13,18,21 * * ?：每天的 0 点、13 点、18 点、21 点都执行一次</li>
<li>0 0 10,14,16 * * ?：每天上午 10 点，下午 2 点，4 点执行一次</li>
<li>0 0&#x2F;30 9-17 * * ?：朝九晚五工作时间内每半小时执行一次</li>
<li>0 0 12 ? * WED：每个星期三中午 12 点执行一次</li>
<li>0 0 12 * * ?：每天中午 12 点触发</li>
<li>0 15 10 ? * *：每天上午 10:15 触发</li>
<li>0 15 10 * * ?：每天上午 10:15 触发</li>
<li>0 15 10 * * ? *：每天上午 10:15 触发</li>
<li>0 15 10 * * ? 2005：2005 年的每天上午 10:15 触发</li>
<li>0 * 14 * * ?：每天下午 2 点到 2:59 期间的每 1 分钟触发</li>
<li>0 0&#x2F;5 14 * * ?：每天下午 2 点到 2:55 期间的每 5 分钟触发</li>
<li>0 0&#x2F;5 14,18 * * ?：每天下午 2 点到 2:55 期间和下午 6 点到 6:55 期间的每 5 分钟触发</li>
<li>0 0-5 14 * * ?：每天下午 2 点到 2:05 期间的每 1 分钟触发</li>
<li>0 10,44 14 ? 3 WED：每年三月的星期三的下午 2:10 和 2:44 触发</li>
<li>0 15 10 ? * MON-FRI：周一至周五的上午 10:15 触发</li>
<li>0 15 10 15 * ?：每月 15 日上午 10:15 触发</li>
<li>0 15 10 L * ?：每月最后一日的上午 10:15 触发</li>
<li>0 15 10 ? * 6L：每月的最后一个星期五上午 10:15 触发</li>
<li>0 15 10 ? * 6L 2002-2005：2002 年至 2005 年的每月的最后一个星期五上午 10:15 触发</li>
<li>0 15 10 ? * 6#3：每月的第三个星期五上午 10:15 触发</li>
</ul>
<h2 id="cron表达式在线计算工具"><a href="#cron表达式在线计算工具" class="headerlink" title="cron表达式在线计算工具"></a>cron表达式在线计算工具</h2><p>写完cron表达式之后，最好使用在线工具，生成未来10次执行时间，人工进行对比，确保写出来的表达式与预期行为一致。</p>
<ul>
<li><a href="https://www.bejson.com/othertools/cronvalidate/">Cron表达式校验工具</a></li>
<li><a href="http://www.yunjson.com/quartzcron/">Quartz Cron定时器表达式生成工具</a></li>
<li><a href="https://cron.qqe2.com/">在线Cron表达式生成器</a></li>
</ul>
<h2 id="Linux下的crontab命令"><a href="#Linux下的crontab命令" class="headerlink" title="Linux下的crontab命令"></a>Linux下的crontab命令</h2><p>请注意，crontab命令使用的 crontab表达式，跟 cron表达式 是有区别的。 </p>
<ul>
<li>cron表达式可以有6个域、7个域。</li>
<li>crontab表达式只有5个域，它不包含秒、不包含年。</li>
<li>crontab表达式对特殊字符的支持也是有限的。</li>
</ul>
<h3 id="crontab表达式"><a href="#crontab表达式" class="headerlink" title="crontab表达式"></a>crontab表达式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab表达式说明：</span><br><span class="line">*    *    *    *    *    [user]   [command]</span><br><span class="line">-    -    -    -    - </span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期 (0 - 7) (Sunday=0 or 7)</span><br><span class="line">|    |    |    +---------- 月 (1 - 12)</span><br><span class="line">|    |    +--------------- 日 (1 - 31)</span><br><span class="line">|    +-------------------- 时 (0 - 23)</span><br><span class="line">+------------------------- 分 (0 - 59)</span><br></pre></td></tr></table></figure>

<h2 id="crontab表达式在线计算工具"><a href="#crontab表达式在线计算工具" class="headerlink" title="crontab表达式在线计算工具"></a>crontab表达式在线计算工具</h2><p>写完crontab表达式之后，最好使用在线工具，生成未来10次执行时间，人工进行对比，确保写出来的表达式与预期行为一致。</p>
<ul>
<li><a href="https://www.iamwawa.cn/crontab.html">crontab执行时间计算</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux命令</category>
        <category>定时任务</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>使用systemd timer实现定时任务</title>
    <url>/posts/16726.html</url>
    <content><![CDATA[<h1 id="使用systemd-timer实现定时任务"><a href="#使用systemd-timer实现定时任务" class="headerlink" title="使用systemd timer实现定时任务"></a>使用systemd timer实现定时任务</h1>]]></content>
      <categories>
        <category>Linux命令</category>
        <category>定时任务</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>scp 命令</title>
    <url>/posts/3277f7fa.html</url>
    <content><![CDATA[<h1 id="Linux下scp命令"><a href="#Linux下scp命令" class="headerlink" title="Linux下scp命令"></a>Linux下scp命令</h1><p>scp可以进行简单的远程复制文件的功能。它是一个在各个主机之间进行复制或文件传输的一个命令工具。它使用一种同ssh一样的安全机制来进行文件的传输。</p>
<span id="more"></span>


<h2 id="scp常规的使用方式"><a href="#scp常规的使用方式" class="headerlink" title="scp常规的使用方式"></a>scp常规的使用方式</h2><p>注意：下面定义的远程计算机的主机域名是 <code>192.168.1.104</code>， 上传文件的路径是 <code>/usr/local/nginx/html/webs</code> 下面的文件；且 服务器的账号是  <code>root</code> ， 那么密码需要自己输入自己的密码即可。</p>
<p>从本地上传文件到远程计算机或服务器的命令如下：</p>
<p>先进入本地目录下，然后运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp my_local_file.zip root@192.168.1.104:/usr/local/nginx/html/webs</span><br></pre></td></tr></table></figure>

<p>从远程主机复制文件到本地主机(下载)的命令如下：（假如远程文件是about.zip）<br>  先进入本地目录下，然后运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp root@192.168.1.104:/usr/local/nginx/html/webs/about.zip .</span><br></pre></td></tr></table></figure>

<h2 id="多文件传输"><a href="#多文件传输" class="headerlink" title="多文件传输"></a>多文件传输</h2><p>从本地文件复制多个文件到远程主机（多个文件使用空格分隔开）<br>先进入本地目录下，然后运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp index.css json.js root@192.168.1.104:/usr/local/nginx/html/webs</span><br></pre></td></tr></table></figure>

<p>从远程主机复制多个文件到当前目录<br>先进入本地目录下，然后运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp root@192.168.1.104:/usr/local/nginx/html/webs/\&#123;index.css,json.js\&#125; .</span><br></pre></td></tr></table></figure>

<h2 id="复制整个文件夹-使用r-switch-并且指定目录"><a href="#复制整个文件夹-使用r-switch-并且指定目录" class="headerlink" title="复制整个文件夹(使用r switch 并且指定目录)"></a>复制整个文件夹(使用r switch 并且指定目录)</h2><p>从本地文件复制整个文件夹到远程主机上（文件夹假如是diff）<br>先进入本地目录下，然后运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -v -r diff root@192.168.1.104:/usr/local/nginx/html/webs</span><br></pre></td></tr></table></figure>

<p>从远程主机复制整个文件夹到本地目录下（文件夹假如是diff）<br>先进入本地目录下，然后运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r root@192.168.1.104:/usr/local/nginx/html/webs/diff .</span><br></pre></td></tr></table></figure>

<h2 id="在两个远程主机之间复制文件"><a href="#在两个远程主机之间复制文件" class="headerlink" title="在两个远程主机之间复制文件"></a>在两个远程主机之间复制文件</h2><p>scp也可以把文件从一个远程主机复制到另一个远程主机上。<br>如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp root@192.168.1.104:/usr/local/nginx/html/webs/xx.txt root@192.168.1.105:/usr/local/nginx/html/webs/</span><br></pre></td></tr></table></figure>

<h2 id="使用压缩来加快传输"><a href="#使用压缩来加快传输" class="headerlink" title="使用压缩来加快传输"></a>使用压缩来加快传输</h2><p>在文件传输的过程中，我们可以使用压缩文件来加快文件传输，我们可以使用 C选项来启用压缩功能，该文件在传输过程中被压缩，<br>在目的主机上被解压缩。</p>
<p>如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -vrC diff root@192.168.1.104:/usr/local/nginx/html/webs</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux命令</category>
        <category>文件管理</category>
      </categories>
      <tags>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统Gnome桌面安装与美化</title>
    <url>/posts/2da80ffc.html</url>
    <content><![CDATA[<h2 id="VMware-Workstation-Pro-桌面虚拟化"><a href="#VMware-Workstation-Pro-桌面虚拟化" class="headerlink" title="VMware Workstation Pro 桌面虚拟化"></a>VMware Workstation Pro 桌面虚拟化</h2><p>使用VMware Workstation Pro 等半虚拟化软件创建的虚拟机。</p>
<ol>
<li>Linux桌面(Gnome)：<ul>
<li>Ubuntu Desktop 22.04 LTS<ul>
<li>Ubuntu 的大版本升级不可靠， 不要做大版本升级；</li>
<li>如果要大版本升级到 24.04 ，请直接重装；</li>
</ul>
</li>
<li>Fedora Workstation 最新版<ul>
<li>Fedora 大版本升级非常可靠， 升级了非常多次，从来没出过问题；</li>
<li>所以，只要出新版，立马升级到新版就好。</li>
<li>如果在 VMware Workstation Pro 里面显示不正常， 关闭3D加速，再试一次。</li>
</ul>
</li>
</ul>
</li>
</ol>
<span id="more"></span>

<ol start="2">
<li>Windows桌面：<ul>
<li>Win10 LTSC 2021</li>
<li>Win11 LTSC</li>
</ul>
</li>
</ol>
<h2 id="安装Ubuntu虚拟机"><a href="#安装Ubuntu虚拟机" class="headerlink" title="安装Ubuntu虚拟机"></a>安装Ubuntu虚拟机</h2><p>1.下载ISO安装镜像，正常安装就好。不会的话就去网上搜教程。</p>
<h3 id="安装需要注意的点"><a href="#安装需要注意的点" class="headerlink" title="安装需要注意的点"></a>安装需要注意的点</h3><p>1.使用lvm创建分区挂载各个挂载点，方便后期磁盘空间扩容。</p>
<p>2.虚拟机安装完成后，一定要在虚拟机里面把vmtools装上，可以提升图形性能，确保可以流畅运行Linux桌面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install open-vm-tools</span><br></pre></td></tr></table></figure>

<p>3.虚拟机设置》处理器》虚拟化引擎，把 <code>虚拟化 Intel VT-x AMD-V</code> 和 <code>虚拟化CPU性能计数器</code> 两个选项都勾上。</p>
<ul>
<li><code>虚拟化 Intel VT-x AMD-V</code>： 虚拟机里面跑docker要用到</li>
<li><code>虚拟化CPU性能计数器</code>： 可以提升虚拟机CPU性能</li>
</ul>
<h2 id="Gnome桌面美化"><a href="#Gnome桌面美化" class="headerlink" title="Gnome桌面美化"></a>Gnome桌面美化</h2>]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
  </entry>
  <entry>
    <title>STL容器库</title>
    <url>/posts/6c4ebde5.html</url>
    <content><![CDATA[<h1 id="STL容器库"><a href="#STL容器库" class="headerlink" title="STL容器库"></a>STL容器库</h1><p>1、顺序容器</p>
<ul>
<li><p><code>std::array</code>  ：静态数组，初始化时确定数组长度，后续不允许改变。</p>
</li>
<li><p><code>std::vector</code> ：动态数组 </p>
</li>
<li><p><code>std::list</code>   ：双向链表 </p>
</li>
<li><p><code>std::deque</code>  ：双端队列 </p>
</li>
<li><p><code>std::forward_list</code> ：单向链表</p>
</li>
<li><p><code>std::inplace_vector</code> ：</p>
</li>
</ul>
<p>2、关联容器（集合、键值对、有序）</p>
<ul>
<li><p><code>std::set</code>  ：存储唯一的、已排序的元素集合。 </p>
</li>
<li><p><code>std::map</code>  ：存储键值对，键是唯一的，并且会按键进行排序。</p>
</li>
<li><p><code>std::multiset</code>  ：</p>
</li>
<li><p><code>std::multimap</code>  ：</p>
</li>
</ul>
<p>3、无序关联容器（集合、键值对、无序）</p>
<ul>
<li><p><code>std::unordered_set</code> ：存储唯一的元素集合，使用哈希表实现，不保证顺序。</p>
</li>
<li><p><code>std::unordered_map</code> ：存储键值对，使用哈希表实现，不保证顺序。</p>
</li>
<li><p><code>std::unordered_multiset</code> ：</p>
</li>
<li><p><code>std::unordered_multimap</code> ：</p>
</li>
</ul>
<p>4、容器适配器</p>
<ul>
<li><code>std::stack</code> ：栈</li>
<li><code>std::queue</code> ：队列</li>
<li><code>std::priority_queue</code> ：优先级队列</li>
</ul>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>C++编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu系统挂载Windows共享文件夹</title>
    <url>/posts/b4f8c94e.html</url>
    <content><![CDATA[<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install cifs-utils</span><br></pre></td></tr></table></figure>


<h2 id="Windows配置"><a href="#Windows配置" class="headerlink" title="Windows配置"></a>Windows配置</h2><p>不要设置每个人都可以读写文件夹，选择一个用户，只允许这个用户可以读写共享文件夹。</p>
<span id="more"></span>


<h2 id="Ubuntu配置"><a href="#Ubuntu配置" class="headerlink" title="Ubuntu配置"></a>Ubuntu配置</h2><h3 id="etc-fstab-文件配置"><a href="#etc-fstab-文件配置" class="headerlink" title="&#x2F;etc&#x2F;fstab 文件配置"></a>&#x2F;etc&#x2F;fstab 文件配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/fstab: static file system information.</span><br><span class="line">#</span><br><span class="line"># Use &#x27;blkid&#x27; to print the universally unique identifier for a</span><br><span class="line"># device; this may be used with UUID= as a more robust way to name devices</span><br><span class="line"># that works even if disks are added and removed. See fstab(5).</span><br><span class="line">#</span><br><span class="line"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><br><span class="line">/dev/mapper/vgubuntu-root /               ext4    errors=remount-ro 0       1</span><br><span class="line"># /boot/efi was on /dev/sda2 during installation</span><br><span class="line">UUID=FB79-6FAD  /boot/efi       vfat    umask=0077      0       1</span><br><span class="line">/dev/mapper/vgubuntu-swap_1 none            swap    sw              0       0</span><br><span class="line"></span><br><span class="line">//172.17.0.1/diskd  /mnt/d  cifs   uid=lukas,username=lukas,password=abc123,iocharset=utf8   0</span><br><span class="line">//172.17.0.1/diske  /mnt/e  cifs   uid=lukas,username=lukas,password=abc123,iocharset=utf8   0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>uid&#x3D;lukas  这里是指定ubuntu用户，不指定的话，你会没有访问权限的。</li>
<li>username&#x3D;lukas,password&#x3D;abc123   这里是windows用户名和密码， (设置windows共享的时候你指定的用户)</li>
</ul>
<h3 id="更安全的配置-etc-fstab"><a href="#更安全的配置-etc-fstab" class="headerlink" title="更安全的配置 &#x2F;etc&#x2F;fstab"></a>更安全的配置 &#x2F;etc&#x2F;fstab</h3><p>&#x2F;etc&#x2F;fstab 每个人都可以读取 - 其中的 Windows 密码也是如此。解决这个问题的方法是使用凭据文件。这是一个仅包含用户名和密码的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lukas@ubuntu24:~$ <span class="built_in">cat</span> /home/lukas/.smbcredentials</span><br><span class="line">username=lukas</span><br><span class="line"></span><br><span class="line">password=abc123</span><br><span class="line">lukas@ubuntu24:~$ <span class="built_in">chmod</span> 600 ~/.smbcredentials</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/fstab: static file system information.</span><br><span class="line">#</span><br><span class="line"># Use &#x27;blkid&#x27; to print the universally unique identifier for a</span><br><span class="line"># device; this may be used with UUID= as a more robust way to name devices</span><br><span class="line"># that works even if disks are added and removed. See fstab(5).</span><br><span class="line">#</span><br><span class="line"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><br><span class="line">/dev/mapper/vgubuntu-root /               ext4    errors=remount-ro 0       1</span><br><span class="line"># /boot/efi was on /dev/sda2 during installation</span><br><span class="line">UUID=FB79-6FAD  /boot/efi       vfat    umask=0077      0       1</span><br><span class="line">/dev/mapper/vgubuntu-swap_1 none            swap    sw              0       0</span><br><span class="line"></span><br><span class="line">//172.17.0.1/diskd  /mnt/d  cifs   credentials=/home/lukas/.smbcredentials   0</span><br><span class="line">//172.17.0.1/diske  /mnt/e  cifs   credentials=/home/lukas/.smbcredentials   0</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://wiki.ubuntu.com/MountWindowsSharesPermanently">https://wiki.ubuntu.com/MountWindowsSharesPermanently</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu系统配置Root用户登录Gnome桌面</title>
    <url>/posts/3b04b6e8.html</url>
    <content><![CDATA[<h3 id="第一步：重新设置Root用户密码"><a href="#第一步：重新设置Root用户密码" class="headerlink" title="第一步：重新设置Root用户密码"></a>第一步：重新设置Root用户密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> passwd root</span><br></pre></td></tr></table></figure>


<h3 id="第二步：配置GDM"><a href="#第二步：配置GDM" class="headerlink" title="第二步：配置GDM"></a>第二步：配置GDM</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/gdm3/custom.conf</span><br></pre></td></tr></table></figure>

<p>添加下列内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[daemon]</span><br><span class="line">AllowRoot=True</span><br></pre></td></tr></table></figure>


<h3 id="第三步：配置PAM认证"><a href="#第三步：配置PAM认证" class="headerlink" title="第三步：配置PAM认证"></a>第三步：配置PAM认证</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/pam.d/gdm-password</span><br></pre></td></tr></table></figure>

<p>添加下列内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auth   required        pam_succeed_if.so user != root quiet_success</span><br><span class="line"></span><br><span class="line">把上面这一行注释掉，修改后的内容为：</span><br><span class="line"></span><br><span class="line"># auth   required        pam_succeed_if.so user != root quiet_success</span><br></pre></td></tr></table></figure>

<h3 id="第四步：重启系统，即可使用Root用户进行登录"><a href="#第四步：重启系统，即可使用Root用户进行登录" class="headerlink" title="第四步：重启系统，即可使用Root用户进行登录"></a>第四步：重启系统，即可使用Root用户进行登录</h3>]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
  </entry>
  <entry>
    <title>CMakeLists用法</title>
    <url>/posts/1d0fb36a.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++开发</category>
        <category>编译系统</category>
      </categories>
  </entry>
  <entry>
    <title>Makefile用法</title>
    <url>/posts/bbd73716.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++开发</category>
        <category>编译系统</category>
      </categories>
  </entry>
  <entry>
    <title>C++包管理器vcpkg</title>
    <url>/posts/a256af5b.html</url>
    <content><![CDATA[<h1 id="C-包管理器vcpkg"><a href="#C-包管理器vcpkg" class="headerlink" title="C++包管理器vcpkg"></a>C++包管理器<code>vcpkg</code></h1><h2 id="vcpkg的基础使用"><a href="#vcpkg的基础使用" class="headerlink" title="vcpkg的基础使用"></a><code>vcpkg</code>的基础使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>学习 Versioning 特性，并且使用 vcpkg 来管理 Cmake 项目的依赖。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://www.cnblogs.com/vcpkg/p/15019907.html">VCPKG 特性 - Versioning</a></li>
<li><a href="https://www.cnblogs.com/vcpkg/p/16791033.html">Manifest使用示例2 - 依赖多个vcpkg的历史版本库</a></li>
</ul>
<h2 id="vcpkg-triplets-与-android-ABI-的对应关系"><a href="#vcpkg-triplets-与-android-ABI-的对应关系" class="headerlink" title="vcpkg triplets 与 android ABI 的对应关系"></a>vcpkg triplets 与 android ABI 的对应关系</h2><ul>
<li><a href="https://learn.microsoft.com/en-us/vcpkg/users/platforms/android">https://learn.microsoft.com/en-us/vcpkg/users/platforms/android</a></li>
<li><a href="https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh-cn/latest/ch08.html">https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh-cn/latest/ch08.html</a></li>
</ul>


<ul>
<li>其中的 <code>neon</code> 是指 <code>neon指令集</code></li>
</ul>
<h3 id="Neon指令集"><a href="#Neon指令集" class="headerlink" title="Neon指令集"></a>Neon指令集</h3><p>Neon 是 ARM 平台的向量化计算指令集，通过一条指令完成多个数据的运算达到加速的目的，常用于 AI、多媒体等计算密集型任务。</p>
<h4 id="Neon指令集-参考资料"><a href="#Neon指令集-参考资料" class="headerlink" title="Neon指令集 参考资料"></a>Neon指令集 参考资料</h4><ul>
<li><a href="https://github.com/rogerou/Arm-neon-intrinsics.git">https://github.com/rogerou/Arm-neon-intrinsics.git</a></li>
</ul>
<h3 id="Android-API-Level-对应关系"><a href="#Android-API-Level-对应关系" class="headerlink" title="Android API Level 对应关系"></a>Android API Level 对应关系</h3><ul>
<li><a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element?hl=zh-cn">https://developer.android.com/guide/topics/manifest/uses-sdk-element?hl=zh-cn</a></li>
</ul>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>编译系统</category>
      </categories>
      <tags>
        <tag>vcpkg</tag>
      </tags>
  </entry>
  <entry>
    <title>LLDB</title>
    <url>/posts/85c1e680.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++开发</category>
        <category>调试工具</category>
      </categories>
  </entry>
  <entry>
    <title>GDB调试C++</title>
    <url>/posts/7f89755.html</url>
    <content><![CDATA[<h2 id="GDB调试基础"><a href="#GDB调试基础" class="headerlink" title="GDB调试基础"></a>GDB调试基础</h2><ol>
<li>命令行传参</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set args aaa bbb</span><br></pre></td></tr></table></figure>

<h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100个GDB小技巧</span><br><span class="line">https://wizardforcel.gitbooks.io/100-gdb-tips/content/break-on-linenum.html</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb 调试利器</span><br><span class="line">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++开发</category>
        <category>调试工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>WinDBG</title>
    <url>/posts/68b6e80b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++开发</category>
        <category>调试工具</category>
      </categories>
  </entry>
  <entry>
    <title>CLion常用快捷键</title>
    <url>/posts/68b6e80b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++开发</category>
        <category>集成开发环境</category>
      </categories>
  </entry>
  <entry>
    <title>源码编译boost库</title>
    <url>/posts/90971b5c.html</url>
    <content><![CDATA[<h2 id="mt-gd-和-mt-s-库有什么区别？"><a href="#mt-gd-和-mt-s-库有什么区别？" class="headerlink" title="mt-gd 和 mt-s 库有什么区别？"></a>mt-gd 和 mt-s 库有什么区别？</h2><p><a href="https://www.boost.org/doc/libs/1_55_0/more/getting_started/windows.html#library-naming">Windows 上的 Boost 入门指南</a> </p>
<p>完整的概述并链接到相应的Visual Studio配置：</p>
<ul>
<li>Boost 的 -mt-s   对应于 VS 的 运行时库 设置 &#x2F;MT</li>
<li>Boost 的 -mt-sgd 对应于 VS 的 运行时库 设置 &#x2F;MTd</li>
<li>Boost 的 -mt     对应于 VS 的 运行时库 设置 &#x2F;MD</li>
<li>Boost 的 -mt-gd  对应于 VS 的 运行时库 设置 &#x2F;MDd</li>
</ul>
<p>第一和第二个可以用 .&#x2F;b2 runtime-link&#x3D;static threading&#x3D;multi</p>
<p>第三和第四个可以用 .&#x2F;b2 runtime-link&#x3D;shared threading&#x3D;multi</p>
<h3 id="Boost库命名规则"><a href="#Boost库命名规则" class="headerlink" title="Boost库命名规则"></a>Boost库命名规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ -mt 是线程标签，表示该库是在启用多线程支持的情况下构建的。</span><br><span class="line">      如果构建的库不支持多线程，则可以通过缺少 `-mt` 来识别。</span><br><span class="line">+ -s  静态链接到 C++ 标准库和编译器运行时支持库。</span><br><span class="line">+ -g  使用标准和运行时支持库的调试版本。</span><br><span class="line">+ -d  使用你的代码的调试版本。</span><br></pre></td></tr></table></figure>
<p>常见组合值有： <code>-mt</code> <code>-mt-gd</code> <code>-mt-s</code> <code>-mt-sgd</code></p>
<h3 id="Visual-Studio-运行库类型"><a href="#Visual-Studio-运行库类型" class="headerlink" title="Visual Studio 运行库类型"></a>Visual Studio 运行库类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行库类型主要包含四种：</span><br><span class="line"></span><br><span class="line">+ 多线程(/MT)</span><br><span class="line">+ 多线程调试(/MTd)</span><br><span class="line">+ 多线程DLL(/MD)</span><br><span class="line">+ 多线程调试(/MDd)</span><br><span class="line"></span><br><span class="line">其中带有d的类型是项目的Debug版本，不带有d的类型是项目的Release版本。</span><br></pre></td></tr></table></figure>

<ul>
<li><code>/MT</code>： 启用多线程支持，静态库，Release版本</li>
<li><code>/MTd</code>：启用多线程支持，静态库，Debug版本</li>
<li><code>/MD</code>： 启用多线程支持，动态库，Release版本</li>
<li><code>/MDd</code>：启用多线程支持，动态库，Debug版本</li>
</ul>
<h2 id="Windows系统-源码编译boost库"><a href="#Windows系统-源码编译boost库" class="headerlink" title="Windows系统 源码编译boost库"></a>Windows系统 源码编译boost库</h2><h3 id="第一步：生成-b2-exe"><a href="#第一步：生成-b2-exe" class="headerlink" title="第一步：生成 b2.exe"></a>第一步：生成 b2.exe</h3><p>执行 bootstrap.bat，即可自动生成。</p>
<p>前提是已经装好对应版本的visual studio，以及相关的C++组件，否则无法正确生成 b2.exe 。</p>
<h3 id="第二步：构建-mt-和-mt-gd-动态运行时库"><a href="#第二步：构建-mt-和-mt-gd-动态运行时库" class="headerlink" title="第二步：构建 -mt 和 -mt-gd 动态运行时库"></a>第二步：构建 -mt 和 -mt-gd 动态运行时库</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 64位</span></span><br><span class="line">.\b2.exe install <span class="literal">--prefix</span>=<span class="string">&quot;D:\AppData\CppDev\MSVC\boost&quot;</span>   address<span class="literal">-model</span>=<span class="number">64</span> link=shared runtime<span class="literal">-link</span>=shared threading=multi <span class="literal">--build-type</span>=complete</span><br></pre></td></tr></table></figure>

<h3 id="第三步：构建-mt-s-和-mt-sgd-静态运行时库"><a href="#第三步：构建-mt-s-和-mt-sgd-静态运行时库" class="headerlink" title="第三步：构建 -mt-s 和 -mt-sgd 静态运行时库"></a>第三步：构建 -mt-s 和 -mt-sgd 静态运行时库</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Debug版本 和 Release版本</span></span><br><span class="line">.\b2.exe install <span class="literal">--prefix</span>=<span class="string">&quot;D:\AppData\CppDev\MSVC\boost&quot;</span>   address<span class="literal">-model</span>=<span class="number">64</span> link=<span class="keyword">static</span> runtime<span class="literal">-link</span>=<span class="keyword">static</span> threading=multi <span class="literal">--build-type</span>=complete</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debug版本</span></span><br><span class="line">.\b2.exe install <span class="literal">--prefix</span>=<span class="string">&quot;D:\AppData\CppDev\MSVC\boost&quot;</span>   address<span class="literal">-model</span>=<span class="number">64</span> link=<span class="keyword">static</span> runtime<span class="literal">-link</span>=<span class="keyword">static</span> threading=multi <span class="literal">--build-type</span>=complete variant=debug</span><br><span class="line"></span><br><span class="line"><span class="comment"># Release版本</span></span><br><span class="line">.\b2.exe install <span class="literal">--prefix</span>=<span class="string">&quot;D:\AppData\CppDev\MSVC\boost&quot;</span>   address<span class="literal">-model</span>=<span class="number">64</span> link=<span class="keyword">static</span> runtime<span class="literal">-link</span>=<span class="keyword">static</span> threading=multi <span class="literal">--build-type</span>=complete variant=release</span><br></pre></td></tr></table></figure>

<h3 id="第四步：在C-项目中配置使用boost静态库"><a href="#第四步：在C-项目中配置使用boost静态库" class="headerlink" title="第四步：在C++项目中配置使用boost静态库"></a>第四步：在C++项目中配置使用boost静态库</h3><p>选择VC++目录—》包含目录，添加 D:\local\dev\boost184-static\x64\include\boost-1_84;</p>
<p>选择VC++目录—》库目录，添加 D:\local\dev\boost184-static\x64\lib;</p>
<h3 id="第五步：在CMake项目中配置使用boost静态库"><a href="#第五步：在CMake项目中配置使用boost静态库" class="headerlink" title="第五步：在CMake项目中配置使用boost静态库"></a>第五步：在CMake项目中配置使用boost静态库</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 配置Boost</span><br><span class="line">if(POLICY CMP0167)</span><br><span class="line">    cmake_policy(SET CMP0167 NEW)</span><br><span class="line">endif()</span><br><span class="line">set(BOOST_ROOT $&#123;THIRD_PARTY_LIBRARY_DIR&#125;/boost)</span><br><span class="line">set(Boost_LIBRARY_DIRS $&#123;THIRD_PARTY_LIBRARY_DIR&#125;/boost/lib)</span><br><span class="line">set(Boost_USE_STATIC_RUNTIME ON)</span><br><span class="line">find_package(Boost 1.89 CONFIG REQUIRED COMPONENTS filesystem regex)</span><br><span class="line"></span><br><span class="line">link_directories($&#123;BOOST_ROOT&#125;/lib)</span><br><span class="line">include_directories($&#123;Boost_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">MESSAGE( STATUS &quot;Boost_INCLUDE_DIRS = $&#123;Boost_INCLUDE_DIRS&#125;.&quot;)</span><br><span class="line">MESSAGE( STATUS &quot;Boost_LIBRARY_DIRS = $&#123;Boost_LIBRARY_DIRS&#125;.&quot;)</span><br><span class="line">MESSAGE( STATUS &quot;Boost_LIBRARIES = $&#123;Boost_LIBRARIES&#125;.&quot;)</span><br><span class="line">MESSAGE( STATUS &quot;Boost_LIB_VERSION = $&#123;Boost_LIB_VERSION&#125;.&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="问题：为什么在链接时不需要指定boost库名，就可以在VS中编译成功？？？"><a href="#问题：为什么在链接时不需要指定boost库名，就可以在VS中编译成功？？？" class="headerlink" title="问题：为什么在链接时不需要指定boost库名，就可以在VS中编译成功？？？"></a>问题：为什么在链接时不需要指定boost库名，就可以在VS中编译成功？？？</h4><ul>
<li>可能只使用了 header only 库</li>
</ul>
<h3 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\b2.exe install <span class="literal">--prefix</span>=<span class="string">&quot;D:\local\dev\boost_1_84_0\static&quot;</span> address<span class="literal">-model</span>=<span class="number">64</span> link=<span class="keyword">static</span> runtime<span class="literal">-link</span>=<span class="keyword">static</span> threading=multi <span class="literal">--build-type</span>=complete</span><br><span class="line"></span><br><span class="line">.\b2.exe install <span class="literal">--prefix</span>=<span class="string">&quot;D:\local\dev\boost_1_84_0\shared&quot;</span> address<span class="literal">-model</span>=<span class="number">64</span> link=shared runtime<span class="literal">-link</span>=shared threading=multi <span class="literal">--build-type</span>=complete</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\b2.exe install <span class="literal">--prefix</span>=<span class="string">&quot;D:\local\dev\boost_1_86_0\static&quot;</span> address<span class="literal">-model</span>=<span class="number">64</span> link=<span class="keyword">static</span> runtime<span class="literal">-link</span>=<span class="keyword">static</span> threading=multi <span class="literal">--build-type</span>=complete</span><br><span class="line"></span><br><span class="line">.\b2.exe install <span class="literal">--prefix</span>=<span class="string">&quot;D:\local\dev\boost_1_86_0\shared&quot;</span> address<span class="literal">-model</span>=<span class="number">64</span> link=shared runtime<span class="literal">-link</span>=shared threading=multi <span class="literal">--build-type</span>=complete</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\b2.exe install <span class="literal">--prefix</span>=<span class="string">&quot;D:\local\dev\boost_1_88_0\static&quot;</span> address<span class="literal">-model</span>=<span class="number">64</span> link=<span class="keyword">static</span> runtime<span class="literal">-link</span>=<span class="keyword">static</span> threading=multi <span class="literal">--build-type</span>=complete</span><br><span class="line"></span><br><span class="line">.\b2.exe install <span class="literal">--prefix</span>=<span class="string">&quot;D:\local\dev\boost_1_88_0\shared&quot;</span> address<span class="literal">-model</span>=<span class="number">64</span> link=shared runtime<span class="literal">-link</span>=shared threading=multi <span class="literal">--build-type</span>=complete</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++开发</category>
        <category>第三方库</category>
      </categories>
  </entry>
  <entry>
    <title>源码编译jemalloc库</title>
    <url>/posts/92cb4bc7.html</url>
    <content><![CDATA[<h2 id="Windows系统-源码编译jemalloc库"><a href="#Windows系统-源码编译jemalloc库" class="headerlink" title="Windows系统 源码编译jemalloc库"></a>Windows系统 源码编译jemalloc库</h2><p>阅读源码下 msvc\ReadMe.txt，并安装必要的组件。</p>
<p>1、安装 MSYS2 ，并安装 ReadMe.txt 中提到的包。然后把 MSYS2 的bin路径加到PATH环境变量里面。</p>
<p>2、Visual studio 2022 里面，安装 Visual C++ 工具集 VC141，VS2022自带的是 VC143 。</p>
<p>3、打开 x64 Native Tools Command Prompt for VS 2022 ，确保可以找到 sh.exe，然后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;CC=cl ./autogen.sh&quot;</span><br></pre></td></tr></table></figure>

<p>4、使用 VS2022 打开 jemalloc_vc2017.sln，不要升级解决方案，调整 windows SDK版本 和 Visual C++ 版本，即可成功生成项目。</p>
<p>5、生成 jemalloc 项目，就可以编译出动、静态库。</p>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>第三方库</category>
      </categories>
  </entry>
  <entry>
    <title>源码编译openssl库</title>
    <url>/posts/abd02a69.html</url>
    <content><![CDATA[<h2 id="Windows系统-源码编译openssl库"><a href="#Windows系统-源码编译openssl库" class="headerlink" title="Windows系统 源码编译openssl库"></a>Windows系统 源码编译openssl库</h2><h3 id="第一步：安装perl、NASM"><a href="#第一步：安装perl、NASM" class="headerlink" title="第一步：安装perl、NASM"></a>第一步：安装perl、NASM</h3><p>从 <a href="https://strawberryperl.com/">https://strawberryperl.com/</a> 下载msi安装包安装Perl。</p>
<p>从 NASM 官网 <a href="https://www.nasm.us/">https://www.nasm.us/</a> 下载并安装 NASM。</p>
<p>把 perl 和 nasm 添加到 PATH 环境变量。 执行 <code>perl -v</code> 检查版本，确保命令行调用的perl是你安装的perl。</p>
<h3 id="第二步：编译openssl库"><a href="#第二步：编译openssl库" class="headerlink" title="第二步：编译openssl库"></a>第二步：编译openssl库</h3><p>编译 64位的库，使用 <code>x64 Native Tools Command Prompt for VS 2022</code>。 编译32位的库，使用 <code>x86 Native Tools Command Prompt for VS 2022</code>。</p>
<p>1、打开 x64 Native Tools Command Prompt for VS 2022 ，切换到 <code>D:\local\source\openssl-3.2.4</code> 目录。</p>
<p>2、编译64位动静态库</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 64位动态库</span></span><br><span class="line">perl Configure VC<span class="literal">-WIN64A</span> <span class="literal">--prefix</span>=D:\local\dev\openssl<span class="literal">-shared</span>\x64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 64位静态库</span></span><br><span class="line">perl Configure VC<span class="literal">-WIN64A</span> no<span class="literal">-shared</span> <span class="literal">--prefix</span>=D:\local\dev\openssl<span class="literal">-static</span>\x64</span><br><span class="line"></span><br><span class="line">nmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装库带Hhtml文档</span></span><br><span class="line">nmake install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装库不带Hhtml文档</span></span><br><span class="line">nmake install_sw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的中间文件</span></span><br><span class="line">nmake clean</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>第三方库</category>
      </categories>
  </entry>
  <entry>
    <title>源码编译libuv库</title>
    <url>/posts/7f1a12a1.html</url>
    <content><![CDATA[<h1 id="源码编译libuv库"><a href="#源码编译libuv库" class="headerlink" title="源码编译libuv库"></a>源码编译libuv库</h1>]]></content>
      <categories>
        <category>C++开发</category>
        <category>第三方库</category>
      </categories>
  </entry>
  <entry>
    <title>Visual Studio C++项目自定义宏</title>
    <url>/posts/a41fbea2.html</url>
    <content><![CDATA[<h2 id="方案一：使用属性管理器"><a href="#方案一：使用属性管理器" class="headerlink" title="方案一：使用属性管理器"></a>方案一：使用属性管理器</h2><p>第一步：视图 》其他窗口 》属性管理器；选中项目，右键，添加新项目属性表，添加 PropertySheet.props 。</p>
<p>第二步：在 属性管理器 里面，选择 PropertySheet 右键选属性，可以找到 用户宏 。</p>
<p>第三步：在 用户宏 里面，添加宏，勾选 将此宏设置为生成环境中的环境变量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Visual C++项目 本身提供的宏已经够用，基本没啥必要自定义宏。</p>
<p>如果是引用第三方库，直接添加绝对路径就好，没必要自定义宏。</p>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>集成开发环境</category>
      </categories>
  </entry>
  <entry>
    <title>Visual Studio C++项目运行时库</title>
    <url>/posts/1fe9dd30.html</url>
    <content><![CDATA[<p>选择C++项目，右键选属性，选择 C&#x2F;C++，选择 代码生成，运行时库选项</p>
<ul>
<li>多线程&#x2F;MT</li>
<li>多线程调试&#x2F;MTd</li>
<li>多线程DLL &#x2F;MD</li>
<li>多线程调试DLL &#x2F;MDd</li>
</ul>
<p>动态运行时库（MD&#x2F;MDd）；静态运行时库（MT&#x2F;MTd）；</p>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>集成开发环境</category>
      </categories>
  </entry>
  <entry>
    <title>未编辑文章</title>
    <url>/posts/68b6e80b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
  </entry>
  <entry>
    <title>Visual Studio C++项目动静态库链接</title>
    <url>/posts/acad9677.html</url>
    <content><![CDATA[<h2 id="使用项目之外的第三方库"><a href="#使用项目之外的第三方库" class="headerlink" title="使用项目之外的第三方库"></a>使用项目之外的第三方库</h2><p>第一步：选中项目，右键属性，选择VC++目录，添加包含目录、库目录。</p>
<p>第二步：选择链接器，选择输入，选择 附加依赖项，填写需要链接的第三方动静态库名称，比如： libssl.lib 。</p>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>集成开发环境</category>
      </categories>
  </entry>
  <entry>
    <title>VSCodeC++开发环境配置</title>
    <url>/posts/6916b507.html</url>
    <content><![CDATA[<h2 id="安装配置MinGW-w64"><a href="#安装配置MinGW-w64" class="headerlink" title="安装配置MinGW-w64"></a>安装配置MinGW-w64</h2><h3 id="下载MinGW-w64"><a href="#下载MinGW-w64" class="headerlink" title="下载MinGW-w64"></a>下载MinGW-w64</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">release地址：</span><br><span class="line">https://github.com/niXman/mingw-builds-binaries/releases/</span><br><span class="line"></span><br><span class="line">具体的tag：</span><br><span class="line">https://github.com/niXman/mingw-builds-binaries/releases/tag/15.2.0-rt_v13-rev0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下载文件：</span><br><span class="line">x86_64-15.2.0-release-posix-seh-ucrt-rt_v13-rev0.7z</span><br><span class="line">x86_64-15.2.0-release-win32-seh-ucrt-rt_v13-rev0.7z</span><br><span class="line"></span><br><span class="line">两个7z压缩文件，任意下载其中一个即可。</span><br></pre></td></tr></table></figure>

<h3 id="解压缩7z压缩文件"><a href="#解压缩7z压缩文件" class="headerlink" title="解压缩7z压缩文件"></a>解压缩7z压缩文件</h3><p>把 x86_64-15.2.0-release-posix-seh-ucrt-rt_v13-rev0.7z 解压后，将 mingw64 文件夹复制到C盘根目录。</p>
<h3 id="添加到环境变量"><a href="#添加到环境变量" class="headerlink" title="添加到环境变量"></a>添加到环境变量</h3><p>把 <code>C:\mingw64\bin</code> 添加到 <code>PATH</code> 环境变量</p>
<h3 id="检查版本信息"><a href="#检查版本信息" class="headerlink" title="检查版本信息"></a>检查版本信息</h3><p><code>CMD</code> 中执行 <code>gcc --version</code> 检查版本信息</p>
<figure class="highlight ps1"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Program Files\PowerShell\<span class="number">7</span>&gt; gcc <span class="literal">--version</span></span><br><span class="line">gcc.exe (x86_64<span class="literal">-win32-seh-rev0</span>, Built by MinGW<span class="literal">-Builds</span> project) <span class="number">15.2</span>.<span class="number">0</span></span><br><span class="line">Copyright (C) <span class="number">2025</span> Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS <span class="keyword">FOR</span> A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:\Program Files\PowerShell\<span class="number">7</span>&gt; <span class="comment"># 上面有正确信息输出，则安装配置成功。</span></span><br></pre></td></tr></table></figure>

<h2 id="VSCode拓展配置"><a href="#VSCode拓展配置" class="headerlink" title="VSCode拓展配置"></a>VSCode拓展配置</h2><h3 id="安装C-拓展"><a href="#安装C-拓展" class="headerlink" title="安装C++拓展"></a>安装C++拓展</h3><p>安装以下三个拓展：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C/C++</span><br><span class="line">C/C++ Extension Pack</span><br><span class="line">C/C++ Themes</span><br></pre></td></tr></table></figure>

<p>在 <code>.vscode</code> 文件夹下，有三个配置文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tasks.json</span><br><span class="line">launch.json</span><br><span class="line">c_cpp_properties.json</span><br></pre></td></tr></table></figure>


<h3 id="配置-tasks-json-文件"><a href="#配置-tasks-json-文件" class="headerlink" title="配置 tasks.json 文件"></a>配置 <code>tasks.json</code> 文件</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GCC编译C++源文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\mingw64\\bin\\g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\bin\\Debug\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;单文件编译任务：使用 MSYS2 MinGW-w64 编译所选择的C++源文件&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-launch-json-文件"><a href="#配置-launch-json-文件" class="headerlink" title="配置 launch.json 文件"></a>配置 <code>launch.json</code> 文件</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试单个源文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\bin\\Debug\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\mingw64\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GCC编译C++源文件&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-c-cpp-properties-json-文件"><a href="#配置-c-cpp-properties-json-文件" class="headerlink" title="配置 c_cpp_properties.json 文件"></a>配置 <code>c_cpp_properties.json</code> 文件</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Win32&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;windowsSdkVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.26100.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\mingw64\\bin\\g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;windows-gcc-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="VSCode使用问题"><a href="#VSCode使用问题" class="headerlink" title="VSCode使用问题"></a>VSCode使用问题</h2><h3 id="IntelliSense-显示不正常"><a href="#IntelliSense-显示不正常" class="headerlink" title="IntelliSense 显示不正常"></a>IntelliSense 显示不正常</h3><p>1、问题描述</p>
<p>使用 <code>#include＜bits/stdc++.h＞</code> 显示红色波浪线。 Windows平台下，默认使用MSVC，MSVC中找不到 <code>bits/stdc++.h</code> ，故而报错，显示红色波浪线。</p>
<p>2、解决方案</p>
<p>改用 Mingw-w64 来执行 IntelliSense 即可解决。</p>
<p>3、具体设置步骤：</p>
<p>将鼠标停留在错误波浪线处，点击Quick Fix(快速修复)-edit “includePath” setting(编辑 “include路径”设置)。<br>然后把其中的编译器路径修改为mingw g++的路径，IntelliSense mode修改为windows-gcc-x64。</p>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>集成开发环境</category>
      </categories>
  </entry>
  <entry>
    <title>VSCode以Root用户启动</title>
    <url>/posts/ae788232.html</url>
    <content><![CDATA[<h2 id="解决方案：从命令行启动"><a href="#解决方案：从命令行启动" class="headerlink" title="解决方案：从命令行启动"></a>解决方案：从命令行启动</h2><p>使用root用户登录Gnome桌面，然后在终端执行下列命令，即可启动VSCode：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">code --no-sandbox --user-data-dir=/root/.vscode</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++开发</category>
        <category>集成开发环境</category>
      </categories>
  </entry>
  <entry>
    <title>VSCode以Root权限调试C++程序</title>
    <url>/posts/b32e9d91.html</url>
    <content><![CDATA[<h2 id="解决方案一：root用户登录"><a href="#解决方案一：root用户登录" class="headerlink" title="解决方案一：root用户登录"></a>解决方案一：root用户登录</h2><p>1、以root用户登录进Gnome桌面</p>
<p>2、以root用户运行vscode</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code --no-sandbox --user-data-dir=/root/.vscode/</span><br></pre></td></tr></table></figure>

<p>3、开始调试C++程序</p>
<h2 id="解决方案二：使用VScode远程开发功能"><a href="#解决方案二：使用VScode远程开发功能" class="headerlink" title="解决方案二：使用VScode远程开发功能"></a>解决方案二：使用VScode远程开发功能</h2><p>1、在windows上面，打开vscode进行远程开发，以root用户的身份远程连接到linux</p>
<p>2、开始调试C++程序</p>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>集成开发环境</category>
      </categories>
  </entry>
  <entry>
    <title>协作式取消（01）：概览</title>
    <url>/posts/2c62c88.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>协作式取消</tag>
      </tags>
  </entry>
  <entry>
    <title>协作式取消（02）：请求取消任务</title>
    <url>/posts/b057b35f.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>协作式取消</tag>
      </tags>
  </entry>
  <entry>
    <title>协作式取消（04）：轮询</title>
    <url>/posts/cb550b20.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>协作式取消</tag>
      </tags>
  </entry>
  <entry>
    <title>三方库Polly：简介</title>
    <url>/posts/954b00f.html</url>
    <content><![CDATA[<p>要详细了解就去看仓库的英文wiki，上面介绍的很详细，搜到的英文翻译很烂，中文跟英文意思相差很大！</p>
<table>
<thead>
<tr>
<th>Policy</th>
<th>前提</th>
<th align="center">Aka</th>
<th>How does the policy mitigate?</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Retry</strong> <br/>(policy family)<br/><sub>(<a href="#retry">quickstart</a>&nbsp;;&nbsp;<a href="https://github.com/App-vNext/Polly/wiki/Retry">deep</a>)</sub></td>
<td>许多故障是暂时的，在一段时间后会正常</td>
<td align="center">“Maybe it’s just a blip”</td>
<td>允许配置自动重试</td>
</tr>
<tr>
<td><strong>Circuit-breaker</strong><br/>(policy family)<br/><sub>(<a href="#circuit-breaker">quickstart</a>&nbsp;;&nbsp;<a href="https://github.com/App-vNext/Polly/wiki/Circuit-Breaker">deep</a>)</sub></td>
<td>当系统发生严重故障时，快速响应请求失败比让用户等待要好。</td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>避免故障系统过载有助于恢复系统。  <br/><br/>Protecting a faulting system from overload can help it recover.</td>
<td>“Stop doing it if it hurts” <br/><br/>“Give that system a break”</td>
<td align="center">当系统错误超过预配置的数量，系统将断路一段时间。</td>
<td></td>
</tr>
<tr>
<td><strong>Timeout</strong><br/><sub>(<a href="#timeout">quickstart</a>&nbsp;;&nbsp;<a href="https://github.com/App-vNext/Polly/wiki/Timeout">deep</a>)</sub></td>
<td>超出一定时间的等待，想要得到正确的结果是不太可能的。</td>
<td align="center">“Don’t wait forever”</td>
<td>保证调用者不需要等待超过设置的超时。</td>
</tr>
<tr>
<td><strong>Bulkhead Isolation</strong><br/><sub>(<a href="#bulkhead">quickstart</a>&nbsp;;&nbsp;<a href="https://github.com/App-vNext/Polly/wiki/Bulkhead">deep</a>)</sub></td>
<td>When a process faults, multiple failing calls backing up can easily swamp resource (eg threads&#x2F;CPU) in a host.<br/><br/>A faulting downstream system can also cause ‘backed-up’ failing calls upstream.<br/><br/>Both risk a faulting process bringing down a wider system.</td>
<td align="center">“One fault shouldn’t sink the whole ship”</td>
<td>Constrains the governed actions to a fixed-size resource pool, isolating their potential  to affect others.</td>
</tr>
<tr>
<td><strong>Cache</strong><br/><sub>(<a href="#cache">quickstart</a>&nbsp;;&nbsp;<a href="https://github.com/App-vNext/Polly/wiki/Cache">deep</a>)</sub></td>
<td>Some proportion of requests may be similar.</td>
<td align="center">“You’ve asked that one before”</td>
<td>Provides a response from cache if known. <br/><br/>Stores responses automatically in cache, when first retrieved.</td>
</tr>
<tr>
<td><strong>Fallback</strong><br/><sub>(<a href="#fallback">quickstart</a>&nbsp;;&nbsp;<a href="https://github.com/App-vNext/Polly/wiki/Fallback">deep</a>)</sub></td>
<td>Things will still fail - plan what you will do when that happens.</td>
<td align="center">“Degrade gracefully”</td>
<td>Defines an alternative value to be returned (or action to be executed) on failure.</td>
</tr>
<tr>
<td><strong>PolicyWrap</strong><br/><sub>(<a href="#policywrap">quickstart</a>&nbsp;;&nbsp;<a href="https://github.com/App-vNext/Polly/wiki/PolicyWrap">deep</a>)</sub></td>
<td>Different faults require different strategies; resilience means using a combination.</td>
<td align="center">“Defence in depth”</td>
<td>Allows any of the above policies to be combined flexibly.</td>
</tr>
</tbody></table>
<h2 id="请求重试"><a href="#请求重试" class="headerlink" title="请求重试"></a>请求重试</h2><p>当发生请求异常或网络错误时, 就重新尝试N次。</p>



<h2 id="请求超时"><a href="#请求超时" class="headerlink" title="请求超时"></a>请求超时</h2><p>当系统超过一定时间的等待，我们就几乎可以判断不可能会有成功的结果。<br>比如平时一个网络请求瞬间就完成了，如果有一次网络请求超过了 30 秒还没完成，我们就知道这次大概率是不会返回成功的结果了。<br>因此，我们需要设置系统的超时时间，避免系统长时间做无谓的等待。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超时时间不能超过 30 秒，否则就认为是错误的结果，并执行回调。</span></span><br><span class="line">Policy.Timeout(<span class="number">30</span>, onTimeout: (context, timespan, task) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="请求断路-Circuit-breaker"><a href="#请求断路-Circuit-breaker" class="headerlink" title="请求断路(Circuit-breaker)"></a>请求断路(Circuit-breaker)</h2><p>断路： 等待一段时间后再继续。</p>
<p>当系统遇到严重问题时，快速回馈失败比让用户&#x2F;调用者等待要好，限制系统出错的体量，有助于系统恢复。<br>比如，当我们去调一个第三方的 API，有很长一段时间 API 都没有响应，可能对方服务器瘫痪了。<br>如果我们的系统还不停地重试，不仅会加重系统的负担，还会可能导致系统其它任务受影响。<br>所以，当系统出错的次数超过了指定的阈值，就要中断当前线路，等待一段时间后再继续。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当系统出现两次异常时，就停下来，等待 1 分钟后再继续。</span></span><br><span class="line">Policy.Handle&lt;SomeException&gt;()</span><br><span class="line">      .CircuitBreaker(<span class="number">2</span>, TimeSpan.FromMinutes(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h2 id="AspNetCore实践使用"><a href="#AspNetCore实践使用" class="headerlink" title="AspNetCore实践使用"></a>AspNetCore实践使用</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SendCloudMailProvider</span> : <span class="title">INoticeProvider</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger _logger;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SendCloudMailProvider</span>(<span class="params">HttpClient httpClient, ILogger&lt;SendCloudMailProvider&gt; logger</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      _httpClient = httpClient;</span><br><span class="line">      _logger = logger;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Polly;</span><br><span class="line"><span class="keyword">using</span> Polly.Extensions.Http;</span><br><span class="line"></span><br><span class="line">services.AddHttpClient&lt;INoticeProvider, SendCloudMailProvider&gt;()</span><br><span class="line">        .AddPolicyHandler(GetRetryPolicy())</span><br><span class="line">        .AddPolicyHandler(GetCircuitBreakerPolicy());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重试策略</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> IAsyncPolicy&lt;HttpResponseMessage&gt; <span class="title">GetRetryPolicy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> HttpPolicyExtensions</span><br><span class="line">      .HandleTransientHttpError()</span><br><span class="line">      .OrResult(msg =&gt; msg.StatusCode == System.Net.HttpStatusCode.NotFound)</span><br><span class="line">      .WaitAndRetryAsync(<span class="number">3</span>, retryAttempt =&gt; TimeSpan.FromMilliseconds(<span class="number">500</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断路策略</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> IAsyncPolicy&lt;HttpResponseMessage&gt; <span class="title">GetCircuitBreakerPolicy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> HttpPolicyExtensions</span><br><span class="line">        .HandleTransientHttpError()</span><br><span class="line">        .CircuitBreakerAsync(<span class="number">5</span>, TimeSpan.FromSeconds(<span class="number">30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
  </entry>
  <entry>
    <title>协作式取消（03）：检测取消请求</title>
    <url>/posts/3fd60f7e.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>协作式取消</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（00）：异步编程模型</title>
    <url>/posts/7acebbf5.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>TaskScheduler</title>
    <url>/posts/19b38a62.html</url>
    <content><![CDATA[<p>Async Await 异步的实现原理，老是被问到， 看了Go的调度器文章，设计上感觉跟这个很相似。</p>
<p>这应该会是一个系列文章， 一篇写不下的， 欠的债慢慢还！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://stackoverflow.com/questions/14177891/understanding-async-await-in-c-sharp">https://stackoverflow.com/questions/14177891/understanding-async-await-in-c-sharp</a><br><a href="https://blog.stephencleary.com/2012/02/async-and-await.html">https://blog.stephencleary.com/2012/02/async-and-await.html</a><br><a href="https://stackoverflow.com/questions/17320595/replacing-the-task-scheduler-in-c-sharp-with-a-custom-built-one">https://stackoverflow.com/questions/17320595/replacing-the-task-scheduler-in-c-sharp-with-a-custom-built-one</a><br><a href="https://www.codeproject.com/Articles/31971/Understanding-SynchronizationContext-Part-I">https://www.codeproject.com/Articles/31971/Understanding-SynchronizationContext-Part-I</a><br><a href="https://stackoverflow.com/questions/15428604/how-to-run-a-task-on-a-custom-taskscheduler-using-await">https://stackoverflow.com/questions/15428604/how-to-run-a-task-on-a-custom-taskscheduler-using-await</a><br><a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?view=net-6.0">https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?view=net-6.0</a><br><a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?view=net-6.0#Sync">https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?view=net-6.0#Sync</a><br><a href="https://devblogs.microsoft.com/pfxteam/taskscheduler-fromcurrentsynchronizationcontext/">https://devblogs.microsoft.com/pfxteam/taskscheduler-fromcurrentsynchronizationcontext/</a></p>
]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（02）：Task类的构造函数</title>
    <url>/posts/38ac44f2.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（01）：概述</title>
    <url>/posts/b4c55247.html</url>
    <content><![CDATA[<h2 id="Delegate-Task-与-Promise-Task"><a href="#Delegate-Task-与-Promise-Task" class="headerlink" title="Delegate Task 与 Promise Task"></a>Delegate Task 与 Promise Task</h2><h2 id="Future与promise"><a href="#Future与promise" class="headerlink" title="Future与promise"></a>Future与promise</h2><ul>
<li><a href="https://zh.wikipedia.org/zh-cn/Future%E4%B8%8Epromise">https://zh.wikipedia.org/zh-cn/Future与promise</a></li>
</ul>
]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（03）：Task类的创建选项</title>
    <url>/posts/32ef9b87.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（05）：任务标识</title>
    <url>/posts/21953ff3.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（06）：阻塞等待任务完成</title>
    <url>/posts/b718d08d.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（04）：任务状态</title>
    <url>/posts/782b44ab.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（07）：取回任务执行结果</title>
    <url>/posts/eda92ef4.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（10）：Delegate Task</title>
    <url>/posts/11ab9be3.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（09）：运行新任务</title>
    <url>/posts/fdd45e6e.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（08）：附加延续任务</title>
    <url>/posts/1366ba2b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手C#异步（11）：Promise Task</title>
    <url>/posts/ba1330f9.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>理解C#异步async-await（2）：Awaitable-Awaiter模式</title>
    <url>/posts/ea061b87.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>理解C#异步async-await（1）：编译</title>
    <url>/posts/7307a51f.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>理解C#异步async-await（3）：运行时上下文</title>
    <url>/posts/472c86e.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>理解SynchronizationContext（1）：它是什么</title>
    <url>/posts/6a0d661b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>理解SynchronizationContext（3）：.NET中的具体实现</title>
    <url>/posts/287c650f.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>理解SynchronizationContext（2）：该类由什么构成</title>
    <url>/posts/9ca82e89.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>理解SynchronizationContext（4）：使用应注意的问题</title>
    <url>/posts/c0ed7c7a.html</url>
    <content><![CDATA[<h3 id="什么是-Awaitable-Awaiter模式？"><a href="#什么是-Awaitable-Awaiter模式？" class="headerlink" title="什么是 Awaitable-Awaiter模式？"></a>什么是 Awaitable-Awaiter模式？</h3><h3 id="为什么会有SynchronizationContext？"><a href="#为什么会有SynchronizationContext？" class="headerlink" title="为什么会有SynchronizationContext？"></a>为什么会有SynchronizationContext？</h3><p>因为同步是在同一个线程里面完成所有操作，但是异步通常要跨越多个线程才能最终执行完所有操作。<br>跨越多个线程的意思是异步任务会在多个线程之间切换执行。<br>为了实现异步任务跨越多个线程执行，需要在线程切换之前，保存异步任务的执行环境，然后在新线程载入执行环境，载入完成之后，才能继续执行异步任务。</p>
<p>SynchronizationContext就是对任务执行环境的抽象。<br>.NET 里面每个 Thread 类都有一个 ExecutionContext 类属性成员，也是对执行环境的抽象， 它是一个容器，用于容纳各种环境抽象的Context，包括但不限于 security context, call context, synchronization context。</p>
<p>文章1： 比较ExecutionContext和SynchronizationContext之间的差异</p>
<h3 id="SynchronizationContext在-NET中的不同实现？"><a href="#SynchronizationContext在-NET中的不同实现？" class="headerlink" title="SynchronizationContext在.NET中的不同实现？"></a>SynchronizationContext在.NET中的不同实现？</h3><p>WPF：系统.Windows.线程。 DispatcherSynchronizationContext （本文的案例）<br>WinForms：系统.Windows.Forms。 WindowsFormsSynchronizationContext<br>WinRT：系统.Threading.WinRTSynchronizationContext<br>ASP.NET：系统.Web。 AspNet同步上下文<br>ASP.NET Core：没有SynchronizationContext，使用线程池线程的ExecutionContext</p>
<p>文章1： 为什么ASP.NET Core 没有SynchronizationContext ？</p>
<h3 id="2-为什么await关键字的实现要捕获-capture-SynchronizationContext？"><a href="#2-为什么await关键字的实现要捕获-capture-SynchronizationContext？" class="headerlink" title="2. 为什么await关键字的实现要捕获(capture) SynchronizationContext？"></a>2. 为什么await关键字的实现要捕获(capture) SynchronizationContext？</h3><p>async&#x2F;await 的具体原理其实就是协程，协程中断(suspend)和协程恢复执行(resume)都需要保存执行环境，而 SynchronizationContext 是对执行环境的抽象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">logger.Info(<span class="string">&quot;await before&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> LoadStringAsync();</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">&quot;await after&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>await 关键字的实现，<br>会在 LoadStringAsync 之前，需要先中断(suspend)，也就是捕获记录 SynchronizationContext，<br>当 LoadStringAsync 执行完成之后， 就需要先恢复执行(resume)，也就是载入之前捕获的SynchronizationContext，然后才能执行<code>await LoadStringAsync</code>这一行后面的代码。<br>这是await关键字的默认行为。 </p>
<p>我们需要关注的是， await会在什么地方恢复继续执行：</p>
<ul>
<li>如果await在线程池线程上恢复，则 CPU 密集型工作将在该线程池线程上运行（这很好）。 </li>
<li>如果它在 UI 线程上恢复，那么 CPU 密集型工作将在 UI 线程上运行（这样不好，CPU 密集型工作不应该放到UI线程上执行，所以应该考虑使用 Task.Run 调度到线程池执行).</li>
</ul>
<p>在进行GUI开发或者三方库开发时， 我们可以使用 <code>ConfigureAwait</code> 来控制SynchronizationContext的默认恢复行为， 从而决定 <code>await LoadStringAsync</code>这一行后面的代码，是在线程池上执行还是在UI线程上执行。这样可以避免因为SynchronizationContext默认行为运行在UI线程上面而产生死锁。</p>
<h3 id="SynchronizationContext的默认行为？"><a href="#SynchronizationContext的默认行为？" class="headerlink" title="SynchronizationContext的默认行为？"></a>SynchronizationContext的默认行为？</h3><p>默认行为指的是中断与恢复， </p>
<ul>
<li>中断： 指的是切换线程之前保存执行环境；</li>
<li>恢复： 指的是在被恢复线程上面载入执行环境，然后继续执行代码。</li>
</ul>
<p>重点在恢复，更具体的讲就是在什么线程上恢复， 可以是UI线程也可以是线程池线程； 但是这两者之间会有很多需要注意的地方，在UI线程上恢复时，使用不当会造成死锁。</p>
<p>异步任务的执行会依赖 SynchronizationContext， 还会依赖 TaskScheduler。</p>
<h3 id="如何实现自定义的-SynchronizationContext-？"><a href="#如何实现自定义的-SynchronizationContext-？" class="headerlink" title="如何实现自定义的 SynchronizationContext ？"></a>如何实现自定义的 SynchronizationContext ？</h3><p>这对理解 SynchronizationContext 是什么很重要。</p>
<h3 id="如何实现自定义的-TaskScheduler-？"><a href="#如何实现自定义的-TaskScheduler-？" class="headerlink" title="如何实现自定义的 TaskScheduler ？"></a>如何实现自定义的 TaskScheduler ？</h3><p>这对理解任务调度的过程和原理来说很重要。</p>
]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>理解SynchronizationContext（7）：自定义TaskScheduler</title>
    <url>/posts/42b4c6e5.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>理解SynchronizationContext（5）：与ExecutionContext的对比</title>
    <url>/posts/20945433.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>Go协程的设计</title>
    <url>/posts/842cad21.html</url>
    <content><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.zhihu.com/question/20862617">https://www.zhihu.com/question/20862617</a><br><a href="https://chasecs.github.io/posts/go-scheduler-introduction/">https://chasecs.github.io/posts/go-scheduler-introduction/</a><br><a href="https://morsmachine.dk/go-scheduler">https://morsmachine.dk/go-scheduler</a></p>
]]></content>
      <categories>
        <category>Go语言开发</category>
      </categories>
      <tags>
        <tag>Go-Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Go 协同程序</title>
    <url>/posts/ba5a34e3.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Go语言开发</category>
      </categories>
      <tags>
        <tag>Goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>理解SynchronizationContext（6）：自定义SynchronizationContext</title>
    <url>/posts/1056f75c.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>.NET开发</category>
      </categories>
      <tags>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>GORM的用法</title>
    <url>/posts/1f5f365d.html</url>
    <content><![CDATA[<h2 id="迁移-AutoMigrate"><a href="#迁移-AutoMigrate" class="headerlink" title="迁移(AutoMigrate)"></a>迁移(AutoMigrate)</h2><ol>
<li>介绍<br>GORM 的 AutoMigrate() 方法用于自动迁移 ORM 的 Schemas。所谓 “迁移” 就是刷新数据库中的表格定义，使其保持最新（只增不减）。</li>
</ol>
<p>AutoMigrate 会创建（新的）表、缺少的外键、约束、列和索引，并且会更改现有列的类型（如果其大小、精度、是否为空可更改的话）。但不会删除未使用的列，以保护现存的数据。</p>
<ol start="2">
<li>数据库版本控制</li>
</ol>
<p>需要注意的是，GORM 虽然提供了不错的数据库迁移功能，但是距离理想的 “版本控制” 仍有距离。不支持，包括：版本记录、版本回退、版本选择。这些都需要开发者自行封装。</p>
<p>这玩意跟 EF Core 比起来就是个弟弟，弱的不能再弱，凑合用！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.51cto.com/u_15301988/3079977">https://blog.51cto.com/u_15301988/3079977</a></p>
]]></content>
      <categories>
        <category>Go语言开发</category>
      </categories>
      <tags>
        <tag>GORM</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin的用法</title>
    <url>/posts/22d2336.html</url>
    <content><![CDATA[<p>Gin 是一个web框架</p>
]]></content>
      <categories>
        <category>Go语言开发</category>
      </categories>
      <tags>
        <tag>Gin</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Module 使用Github私有仓库</title>
    <url>/posts/43981311.html</url>
    <content><![CDATA[<h1 id="Go-Module-使用Github私有仓库"><a href="#Go-Module-使用Github私有仓库" class="headerlink" title="Go Module 使用Github私有仓库"></a>Go Module 使用Github私有仓库</h1><h2 id="使用-Access-Token-进行访问"><a href="#使用-Access-Token-进行访问" class="headerlink" title="使用 Access Token 进行访问"></a>使用 Access Token 进行访问</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\lukas&gt;<span class="built_in">Set-Variable</span> <span class="literal">-name</span> username <span class="literal">-value</span> lukas</span><br><span class="line"><span class="built_in">PS</span> C:\Users\lukas&gt;<span class="built_in">Set-Variable</span> <span class="literal">-name</span> access_token <span class="literal">-value</span> xxxxxxxxxxxx</span><br><span class="line"><span class="built_in">PS</span> C:\Users\lukas&gt; go env <span class="literal">-w</span> GOPRIVATE=github.com/<span class="variable">$</span>&#123;username&#125;</span><br><span class="line"><span class="built_in">PS</span> C:\Users\lukas&gt; git config <span class="literal">--global</span> url.<span class="string">&quot;https://<span class="variable">$</span>&#123;username&#125;:<span class="variable">$</span>&#123;access_token&#125;@github.com&quot;</span>.insteadOf <span class="string">&quot;https://github.com&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\lukas&gt; <span class="built_in">cd</span> D:\tmp</span><br><span class="line"><span class="built_in">PS</span> D:\tmp&gt;</span><br><span class="line"><span class="built_in">PS</span> D:\tmp&gt; go get github.com/lukas/blueberry/examples</span><br><span class="line">go: downloading github.com/lukas/blueberry/examples v0.<span class="number">0.0</span><span class="literal">-20240329033644-5f967cf0e366</span></span><br><span class="line">go: downloading github.com/lukas/blueberry v0.<span class="number">0.0</span><span class="literal">-20240329033644-5f967cf0e366</span></span><br><span class="line">go: added github.com/lukas/blueberry/examples v0.<span class="number">0.0</span><span class="literal">-20240329033644-5f967cf0e366</span></span><br><span class="line"><span class="built_in">PS</span> D:\tmp&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go语言开发</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Pgx-tern迁移的用法</title>
    <url>/posts/404ab945.html</url>
    <content><![CDATA[<p>tern 是一个 pgx 配套的pg迁移工具。</p>
]]></content>
      <categories>
        <category>Go语言开发</category>
      </categories>
      <tags>
        <tag>PGX</tag>
        <tag>Tern</tag>
      </tags>
  </entry>
  <entry>
    <title>HAProxy四层代理HTTPS</title>
    <url>/posts/9c421140.html</url>
    <content><![CDATA[<h2 id="HAProxy四层代理HTTPS"><a href="#HAProxy四层代理HTTPS" class="headerlink" title="HAProxy四层代理HTTPS"></a>HAProxy四层代理HTTPS</h2><h3 id="HAProxy配置"><a href="#HAProxy配置" class="headerlink" title="HAProxy配置"></a>HAProxy配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">    log /dev/log  local0 warning</span><br><span class="line">    chroot      /var/lib/haproxy</span><br><span class="line">    pidfile     /var/run/haproxy.pid</span><br><span class="line">    maxconn     4000</span><br><span class="line">    user        haproxy</span><br><span class="line">    group       haproxy</span><br><span class="line">    daemon</span><br><span class="line">   stats socket /var/lib/haproxy/stats</span><br><span class="line">   tune.bufsize 32768</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">  log global</span><br><span class="line">  option  httplog</span><br><span class="line">  option  dontlognull</span><br><span class="line">        timeout connect 5000</span><br><span class="line">        timeout client 50000</span><br><span class="line">        timeout server 50000</span><br><span class="line"></span><br><span class="line">frontend apiserver-frontend</span><br><span class="line">  bind *:8443</span><br><span class="line">  mode tcp</span><br><span class="line">  option tcplog</span><br><span class="line">  default_backend apiserver-backend</span><br><span class="line"></span><br><span class="line">backend apiserver-backend</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    option tcp-check</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server api-apiserver-1 172.17.2.11:443 check</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="测试结果：成功"><a href="#测试结果：成功" class="headerlink" title="测试结果：成功"></a>测试结果：成功</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@SuperWS-86e926a7 ~]# curl https://test.pve.local:8443 -vvvvv</span><br><span class="line">* Host test.pve.local:8443 was resolved.</span><br><span class="line">* IPv6: (none)</span><br><span class="line">* IPv4: 172.17.2.11</span><br><span class="line">*   Trying 172.17.2.11:8443...</span><br><span class="line">* Connected to test.pve.local (172.17.2.11) port 8443</span><br><span class="line">* ALPN: curl offers h2,http/1.1</span><br><span class="line">* TLSv1.3 (OUT), TLS handshake, Client hello (1):</span><br><span class="line">*  CAfile: /etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">*  CApath: none</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Server hello (2):</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Certificate (11):</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, CERT verify (15):</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Finished (20):</span><br><span class="line">* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):</span><br><span class="line">* TLSv1.3 (OUT), TLS handshake, Finished (20):</span><br><span class="line">* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384 / x25519 / id-ecPublicKey</span><br><span class="line">* ALPN: server accepted http/1.1</span><br><span class="line">* Server certificate:</span><br><span class="line">*  subject: C=USA; ST=California; L=San Francisco; O=SuperWS; OU=Administrator; CN=*.pve.local</span><br><span class="line">*  start <span class="built_in">date</span>: Oct 31 10:11:00 2025 GMT</span><br><span class="line">*  expire <span class="built_in">date</span>: Oct 29 10:11:00 2035 GMT</span><br><span class="line">*  subjectAltName: host <span class="string">&quot;test.pve.local&quot;</span> matched cert<span class="string">&#x27;s &quot;*.pve.local&quot;</span></span><br><span class="line"><span class="string">*  issuer: C=USA; ST=California; L=San Francisco; O=SuperWS; OU=Administration; CN=SuperWS Intermediate CA 2025 ECC</span></span><br><span class="line"><span class="string">*  SSL certificate verify ok.</span></span><br><span class="line"><span class="string">*   Certificate level 0: Public key type EC/secp384r1 (384/192 Bits/secBits), signed using ecdsa-with-SHA384</span></span><br><span class="line"><span class="string">*   Certificate level 1: Public key type EC/secp384r1 (384/192 Bits/secBits), signed using ecdsa-with-SHA384</span></span><br><span class="line"><span class="string">* using HTTP/1.x</span></span><br><span class="line"><span class="string">&gt; GET / HTTP/1.1</span></span><br><span class="line"><span class="string">&gt; Host: test.pve.local:8443</span></span><br><span class="line"><span class="string">&gt; User-Agent: curl/8.9.1</span></span><br><span class="line"><span class="string">&gt; Accept: */*</span></span><br><span class="line"><span class="string">&gt;</span></span><br><span class="line"><span class="string">* Request completely sent off</span></span><br><span class="line"><span class="string">* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):</span></span><br><span class="line"><span class="string">* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):</span></span><br><span class="line"><span class="string">&lt; HTTP/1.1 200 OK</span></span><br><span class="line"><span class="string">&lt; Server: nginx</span></span><br><span class="line"><span class="string">&lt; Date: Sun, 02 Nov 2025 14:08:52 GMT</span></span><br><span class="line"><span class="string">&lt; Content-Type: text/plain</span></span><br><span class="line"><span class="string">&lt; Content-Length: 12</span></span><br><span class="line"><span class="string">&lt; Connection: keep-alive</span></span><br><span class="line"><span class="string">&lt; X-Frame-Options: SAMEORIGIN</span></span><br><span class="line"><span class="string">&lt; X-XSS-Protection: 1; mode=block</span></span><br><span class="line"><span class="string">&lt; X-Content-Type-Options: nosniff</span></span><br><span class="line"><span class="string">&lt;</span></span><br><span class="line"><span class="string">* Connection #0 to host test.pve.local left intact</span></span><br><span class="line"><span class="string">test_success[root@SuperWS-86e926a7 ~]#</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>反向代理与负载均衡</category>
        <category>HAProxy</category>
      </categories>
  </entry>
  <entry>
    <title>blkid 命令</title>
    <url>/posts/5.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Linux命令</category>
        <category>存储管理</category>
      </categories>
      <tags>
        <tag>存储管理</tag>
      </tags>
  </entry>
  <entry>
    <title>XFS文件系统异常断电修复</title>
    <url>/posts/7f5cb13b.html</url>
    <content><![CDATA[<h2 id="异常断电导致xfs文件系统出错"><a href="#异常断电导致xfs文件系统出错" class="headerlink" title="异常断电导致xfs文件系统出错"></a>异常断电导致xfs文件系统出错</h2><p>问题描述，因为异常断电，xfs文件系统异常，无法正常开机启动系统。</p>
<p>因为文件系统是基于lvm创建的， 开机启动时，提示  &#x2F;dev&#x2F;pve&#x2F;root 无法挂载到 &#x2F; ， 需要修复。</p>
<span id="more"></span>

<h3 id="如何修复？"><a href="#如何修复？" class="headerlink" title="如何修复？"></a>如何修复？</h3><p>因为磁盘是使用lvm创建的，所有需要先激活卷组和逻辑卷。</p>
<ol>
<li><p>扫描卷组</p>
<p> 使用 vgscan 扫描，可以发现一个叫 pve 的卷组</p>
</li>
<li><p>激活卷组</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vgchange -ay  pve</span><br></pre></td></tr></table></figure>

<p> 注意： 激活卷组，只是激活而已，并没有挂载到系统</p>
</li>
<li><p>现在可以使用 lvscan 查看逻辑卷</p>
</li>
<li><p>修复之前，先尝试看能不能正常挂载</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /asdf</span><br><span class="line">mount /dev/pve/root /asdf</span><br></pre></td></tr></table></figure>
<p> 执行 mount 命令发现，无法挂载</p>
</li>
<li><p>使用 xfs_repair 进行修复</p>
<p> 先使用 xfs_repair 进行修复。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xfs_repair /dev/pve/root</span><br></pre></td></tr></table></figure>

<p> 如果不行，再使用 -L 选项强制修复， 此选项会清除文件系统的log日志。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xfs_repair -L /dev/pve/root</span><br></pre></td></tr></table></figure>
</li>
<li><p>修复之后，尝试重新挂载</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /asdf</span><br><span class="line">mount /dev/pve/root /asdf</span><br></pre></td></tr></table></figure>

<p> 执行 mount 命令后发现，现在可以正常挂载， 问题已修复。 可以重启。</p>
</li>
</ol>
<h2 id="lvm相关命令"><a href="#lvm相关命令" class="headerlink" title="lvm相关命令"></a>lvm相关命令</h2><p>dm是device mapper的意思，dm-0, dm-1的实体可以通过下面几个命令看出，lvm会把每个lv连接到一个&#x2F;dev&#x2F;dm-x的设备档，这个设备档并不是一个真正的磁盘，所以不会有分区表存在，不能把dm设备分区。</p>
<ol>
<li><p><code>iostat -d 1</code> ,可以查看device的实时I&#x2F;O</p>
</li>
<li><p><code>dmsetup ls</code></p>
<p> <code>dmsetup info</code> 可以来查看dm设备（lvm）映射情况，可以看到主设备号，次设备号，看不到物理硬盘信息（sda&#x2F;sdb）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux命令</category>
        <category>存储管理</category>
      </categories>
      <tags>
        <tag>存储管理</tag>
      </tags>
  </entry>
  <entry>
    <title>fio 命令</title>
    <url>/posts/4.html</url>
    <content><![CDATA[<h1 id="fio命令"><a href="#fio命令" class="headerlink" title="fio命令"></a>fio命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost kafka]# dnf install fio</span><br><span class="line"></span><br><span class="line">[root@localhost kafka]# fio --version</span><br><span class="line">fio-3.21</span><br><span class="line">[root@localhost kafka]#</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux命令</category>
        <category>存储管理</category>
      </categories>
      <tags>
        <tag>磁盘性能分析</tag>
      </tags>
  </entry>
  <entry>
    <title>iotop 命令</title>
    <url>/posts/3.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Linux命令</category>
        <category>存储管理</category>
      </categories>
      <tags>
        <tag>磁盘性能分析</tag>
      </tags>
  </entry>
  <entry>
    <title>hdparm 命令</title>
    <url>/posts/1.html</url>
    <content><![CDATA[<h1 id="hdparm-命令"><a href="#hdparm-命令" class="headerlink" title="hdparm 命令"></a>hdparm 命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost kafka]# um -y install hdparm</span><br><span class="line">[root@localhost kafka]# hdparm -V</span><br><span class="line">hdparm v9.58</span><br><span class="line">[root@localhost kafka]#</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux命令</category>
        <category>存储管理</category>
      </categories>
      <tags>
        <tag>磁盘性能分析</tag>
      </tags>
  </entry>
  <entry>
    <title>parted 命令</title>
    <url>/posts/26101.html</url>
    <content><![CDATA[<h1 id="磁盘管理工具-parted"><a href="#磁盘管理工具-parted" class="headerlink" title="磁盘管理工具 parted"></a>磁盘管理工具 parted</h1><h2 id="磁盘分区步骤"><a href="#磁盘分区步骤" class="headerlink" title="磁盘分区步骤"></a>磁盘分区步骤</h2><ul>
<li>1、mklabel     设置分区表</li>
<li>2、unit        设置分区时使用的磁盘容量单位</li>
<li>3、mkpart      设置分区</li>
<li>4、align-check 检查分区是否对齐</li>
<li>4、toggle      设置分区标志</li>
</ul>
<h2 id="第一步、mklabel-设置分区表"><a href="#第一步、mklabel-设置分区表" class="headerlink" title="第一步、mklabel 设置分区表"></a>第一步、mklabel 设置分区表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu2204:~# parted /dev/sda</span><br><span class="line">GNU Parted 3.4</span><br><span class="line">Using /dev/sda</span><br><span class="line">Welcome to GNU Parted! Type <span class="string">&#x27;help&#x27;</span> to view a list of commands.</span><br><span class="line">(parted) p                                                                </span><br><span class="line">Model: QEMU QEMU HARDDISK (scsi)</span><br><span class="line">Disk /dev/sda: 275GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">(parted) <span class="built_in">help</span> mklabel                                                     </span><br><span class="line">  mklabel,mktable LABEL-TYPE               create a new disklabel (partition table)</span><br><span class="line"></span><br><span class="line">	LABEL-TYPE is one of: aix, amiga, bsd, dvh, gpt, mac, msdos, pc98, sun, atari, loop</span><br><span class="line">(parted)</span><br></pre></td></tr></table></figure>

<p>msdos 是MBR分区表， gpt 是GPT分区表。</p>
<h2 id="第二步、unit-设置分区时使用的磁盘容量单位"><a href="#第二步、unit-设置分区时使用的磁盘容量单位" class="headerlink" title="第二步、unit 设置分区时使用的磁盘容量单位"></a>第二步、unit 设置分区时使用的磁盘容量单位</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu2204:~# parted /dev/sda</span><br><span class="line">GNU Parted 3.4</span><br><span class="line">Using /dev/sda</span><br><span class="line">Welcome to GNU Parted! Type <span class="string">&#x27;help&#x27;</span> to view a list of commands.</span><br><span class="line">(parted) p                                                                </span><br><span class="line">Model: QEMU QEMU HARDDISK (scsi)</span><br><span class="line">Disk /dev/sda: 275GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  1128MB  1127MB  fat32              boot, esp</span><br><span class="line"> 2      1128MB  275GB   274GB</span><br><span class="line">(parted) <span class="built_in">help</span> unit                                                        </span><br><span class="line">  unit UNIT                                <span class="built_in">set</span> the default unit to UNIT</span><br><span class="line"></span><br><span class="line">	UNIT is one of: s, , compact, cyl, chs, %, kiB, MiB, GiB, TiB</span><br></pre></td></tr></table></figure>

<h3 id="单位为-B-kB-MB-GB-TB-时"><a href="#单位为-B-kB-MB-GB-TB-时" class="headerlink" title="单位为 B, kB, MB, GB, TB 时"></a>单位为 B, kB, MB, GB, TB 时</h3><p>这些单位使用 1000 进行转换。1 MB &#x3D; 1000 kB，1 GB &#x3D; 1000 MB，1 TB &#x3D; 1000 GB。</p>
<p>对上面 Start 为 1049kB 的解释计算：</p>
<p>1 MiB &#x3D; 1024 KiB &#x3D; 1048576 B &#x3D; 1048.576 kB ≈ 1049 kB</p>
<p>由此，可以看出，parted分区起点，其实是以 1MiB为起点的。</p>
<h3 id="单位为-B-kiB-MiB-GiB-TiB-时"><a href="#单位为-B-kiB-MiB-GiB-TiB-时" class="headerlink" title="单位为 B, kiB, MiB, GiB, TiB 时"></a>单位为 B, kiB, MiB, GiB, TiB 时</h3><p>这些单位使用 1024 进行转换。1 MiB &#x3D; 1024 kiB，1 GiB &#x3D; 1024 MiB，1 TiB &#x3D; 1024 GiB。</p>
<p>1 MiB &#x3D; 1024 KiB &#x3D; 1048576 B &#x3D; 1048.576 kB ≈ 1049 kB</p>
<h3 id="单位为-时，表示使用百分比。"><a href="#单位为-时，表示使用百分比。" class="headerlink" title="单位为 % 时，表示使用百分比。"></a>单位为 % 时，表示使用百分比。</h3><h3 id="单位为-s-cyl-chs-时"><a href="#单位为-s-cyl-chs-时" class="headerlink" title="单位为 s, cyl, chs 时"></a>单位为 s, cyl, chs 时</h3><p>s 表示扇区（Sector），cyl 表示柱面（Cylinder），chs 表示（Cylinder-Head-Sector）表示法， Head（磁头）。</p>
<h2 id="第三步、mkpart-设置分区"><a href="#第三步、mkpart-设置分区" class="headerlink" title="第三步、mkpart 设置分区"></a>第三步、mkpart 设置分区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu2204:~# parted /dev/sda</span><br><span class="line">GNU Parted 3.4</span><br><span class="line">Using /dev/sda</span><br><span class="line">Welcome to GNU Parted! Type <span class="string">&#x27;help&#x27;</span> to view a list of commands.</span><br><span class="line">(parted) p                                                                </span><br><span class="line">Model: QEMU QEMU HARDDISK (scsi)</span><br><span class="line">Disk /dev/sda: 275GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  1128MB  1127MB  fat32              boot, esp</span><br><span class="line"> 2      1128MB  275GB   274GB</span><br><span class="line"></span><br><span class="line">(parted) <span class="built_in">help</span> mkpart                                                      </span><br><span class="line">  mkpart PART-TYPE [FS-TYPE] START END     make a partition</span><br><span class="line"></span><br><span class="line">	PART-TYPE is one of: primary, logical, extended</span><br><span class="line">        FS-TYPE is one of: zfs, udf, btrfs, nilfs2, ext4, ext3, ext2, f2fs, fat32, fat16, hfsx, hfs+, hfs, jfs, swsusp, linux-swap(v1), linux-swap(v0), ntfs, reiserfs, freebsd-ufs, hp-ufs, sun-ufs, xfs, apfs2, apfs1, asfs, amufs5,</span><br><span class="line">        amufs4, amufs3, amufs2, amufs1, amufs0, amufs, affs7, affs6, affs5, affs4, affs3, affs2, affs1, affs0, linux-swap, linux-swap(new), linux-swap(old)</span><br><span class="line">        START and END are disk locations, such as 4GB or 10%.  Negative values count from the end of the disk.  For example, -1s specifies exactly the last sector.</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;mkpart&#x27;</span> makes a partition without creating a new file system on the partition.  FS-TYPE may be specified to <span class="built_in">set</span> an appropriate partition ID.</span><br><span class="line">(parted) </span><br></pre></td></tr></table></figure>

<p>进行分区操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mklabel gpt</span><br><span class="line">unit kB</span><br><span class="line">mkpart primary fat32 1049kB 1128MB</span><br><span class="line">mkpart primary fat32 1128MB 275GB</span><br></pre></td></tr></table></figure>

<h2 id="第四步、检查分区是否对齐"><a href="#第四步、检查分区是否对齐" class="headerlink" title="第四步、检查分区是否对齐"></a>第四步、检查分区是否对齐</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  2097kB  1049kB                     bios_grub</span><br><span class="line"> 2      2097kB  550GB   550GB</span><br><span class="line"></span><br><span class="line">(parted) align-check opt 1</span><br><span class="line">1 aligned</span><br><span class="line">(parted)</span><br></pre></td></tr></table></figure>

<h2 id="第五步、toggle-设置分区标志"><a href="#第五步、toggle-设置分区标志" class="headerlink" title="第五步、toggle  设置分区标志"></a>第五步、toggle  设置分区标志</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu2204:~# parted /dev/sda</span><br><span class="line">GNU Parted 3.4</span><br><span class="line">Using /dev/sda</span><br><span class="line">Welcome to GNU Parted! Type <span class="string">&#x27;help&#x27;</span> to view a list of commands.</span><br><span class="line">(parted) p                                                                </span><br><span class="line">Model: QEMU QEMU HARDDISK (scsi)</span><br><span class="line">Disk /dev/sda: 275GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  1128MB  1127MB  fat32              boot, esp</span><br><span class="line"> 2      1128MB  275GB   274GB</span><br><span class="line"></span><br><span class="line">(parted) <span class="built_in">help</span> toggle </span><br><span class="line">  toggle [NUMBER [FLAG]]                   toggle the state of FLAG on partition NUMBER</span><br><span class="line"></span><br><span class="line">	NUMBER is the partition number used by Linux.  On MS-DOS disk labels, the primary partitions number from 1 to 4, logical partitions from 5 onwards.</span><br><span class="line">        FLAG is one of: boot, root, swap, hidden, raid, lvm, lba, hp-service, palo, prep, msftres, bios_grub, atvrecv, diag, legacy_boot, msftdata, irst, esp, chromeos_kernel, bls_boot</span><br><span class="line">(parted)</span><br><span class="line"></span><br><span class="line">root@app01:~# parted /dev/sda -l</span><br><span class="line">Model: QEMU QEMU HARDDISK (scsi)</span><br><span class="line">Disk /dev/sda: 550GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  2097kB  1049kB                     bios_grub</span><br><span class="line"> 2      2097kB  550GB   550GB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Model: Linux device-mapper (linear) (dm)</span><br><span class="line">Disk /dev/mapper/ubuntu-root: 550GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: loop</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start  End    Size   File system  Flags</span><br><span class="line"> 1      0.00B  550GB  550GB  xfs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>bios_grub，可用于GPT分区表，表示所选分区是 Grub Bios分区。</p>
<p>esp，可用于GPT分区表，表示这是一个UEFI引导使用的EFI分区。On GPT it is an alias for boot.</p>
<p>boot (Mac, MS-DOS, PC98) - 启动分区</p>
<p>swap表示交换分区。</p>
<p>lvm 表示该分区是lvm pv。</p>
<p>在Linux下，Grub支持多种不同类型的启动方式。</p>
<ul>
<li>第一种、BIOS + MBR分区表</li>
<li>第二种、BIOS + GPT分区表</li>
<li>第三种、UEFI + GPT分区表</li>
</ul>
<h3 id="第一种、BIOS-MBR分区表"><a href="#第一种、BIOS-MBR分区表" class="headerlink" title="第一种、BIOS + MBR分区表"></a>第一种、BIOS + MBR分区表</h3><p>当你按照第一种方式进行安装系统时，GRUB要求设置一个boot分区挂载到 <code>/boot</code> ，容量不低于于1GB，分区标志Flags设置为boot，用于启动系统。</p>
<p>当然，你还需要一个分区，用于挂载 <code>/</code> ，一个分区用于swap交换分区。</p>
<p>MBR分区表下，没有明确指定的地方存放GRUB相关代码，因此GRUB代码各个地方存放一部分，表现的很混乱，聪明的开发人员使用了黑客攻击劫持的手段使其运行起来。</p>
<h3 id="第二种、BIOS-GPT分区表"><a href="#第二种、BIOS-GPT分区表" class="headerlink" title="第二种、BIOS + GPT分区表"></a>第二种、BIOS + GPT分区表</h3><p>当你按照第二种方式进行安装系统时，GRUB要求设置一个分区，容量为1MB，分区标志Flags设置为bios_grub，用于存放GRUB相关处理代码。</p>
<p>当然，你还需要一个分区，用于挂载 <code>/</code> ，一个分区用于swap交换分区。</p>
<p>为什么要有bios_grub这样的一个分区呢？ </p>
<p>因为GPT分区表没有提供地方给GRUB存放GRUB相关处理代码，所以GRUB开发者，就自己设置了这样一个分区，专门用于GRUB。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/BIOS_boot_partition">BIOS_boot_partition</a></li>
</ul>
<h3 id="第三种、UEFI-GPT分区表"><a href="#第三种、UEFI-GPT分区表" class="headerlink" title="第三种、UEFI + GPT分区表"></a>第三种、UEFI + GPT分区表</h3><p>当你按照第三种方式进行安装系统时，你需要设置一个fat32格式的EFI分区挂载到 <code>/boot/efi</code>，容量300MB，分区标志Flags设置为<code>boot,esp</code>。</p>
<p>当然，你还需要一个分区，用于挂载 <code>/</code> ，一个分区用于swap交换分区。采用第三种方式时，你不需要单独创建一个分区来挂载到<code>/boot</code>。</p>
]]></content>
      <categories>
        <category>Linux命令</category>
        <category>存储管理</category>
      </categories>
      <tags>
        <tag>存储管理</tag>
      </tags>
  </entry>
  <entry>
    <title>iostat 命令</title>
    <url>/posts/2.html</url>
    <content><![CDATA[<p>apt install -y sysstat net-tools linux-tools-common iotop dstat systemtap</p>
]]></content>
      <categories>
        <category>Linux命令</category>
        <category>存储管理</category>
      </categories>
      <tags>
        <tag>磁盘性能分析</tag>
      </tags>
  </entry>
</search>
